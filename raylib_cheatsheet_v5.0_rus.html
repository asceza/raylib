<!DOCTYPE html>
<!-- saved from url=(0056)file:///D:/Asceza/raylib/raylib_cheatsheet_v5.0_rus.html -->
<html class=""><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

        <title>raylib_cheatsheet_v5.0_rus</title>
        

        <meta name="title" content="raylib - cheatsheet">
        <meta name="description" content="raylib is a simple and easy-to-use library to enjoy videogames programming. Don&#39;t miss latest functions added to raylib... check raylib cheatsheet">
        <meta name="keywords" content="raylib, videogames, programming, C, C++, library, learn, study, simple, easy, free, open source, raysan">
        <meta name="viewport" content="width=device-width">

        <!-- Open Graph metatags for sharing -->
        <meta property="og:title" content="raylib - cheatsheet">
        <meta property="og:image" content="https://www.raylib.com/common/img/raylib_logo_card.png">
        <meta property="og:url" content="https://www.raylib.com">
        <meta property="og:site_name" content="raylib">
        <meta property="og:description" content="Don&#39;t miss latest functions added to raylib... check raylib cheatsheet">

        <!-- Add jQuery library -->
        <script type="text/javascript" src="./raylib_cheatsheet_v5.0_rus_files/jquery-latest.min.js.Без названия"></script>

        <!-- hightlight.js - Syntax highlighting for the Web -->
        <link rel="stylesheet" href="./raylib_cheatsheet_v5.0_rus_files/docco.min.css">
        <script src="./raylib_cheatsheet_v5.0_rus_files/highlight.min.js.Без названия"></script>

        <style type="text/css">
         @font-face {
             font-family: 'grixel_acme_7_wide_xtnd';
             src: url('../common/font/acme_7_wide_xtnd.eot');
             src: url('../common/font/acme_7_wide_xtnd.eot?#iefix') format('embedded-opentype'),
             url('../common/font/acme_7_wide_xtnd.woff') format('woff'),
             url('../common/font/acme_7_wide_xtnd.ttf') format('truetype');
             font-weight: normal;
             font-style: normal;
             font-size-adjust:0.49;
         }
         body{background-color:#f5f5f5;}
         #fulldata{width: 1315px!important;}
         .eximage img{margin: 0 auto; border: 1px solid; border-color: black; width:770px; height:auto;}
         p{font-family: grixel_acme_7_wide_xtnd, Courier New, Verdana, Arial; font-size:13px; line-height:24px;}
         a{font-family: grixel_acme_7_wide_xtnd, Courier New, Verdana, Arial; font-size:13px; line-height:24px;}
         pre code{font-family: Courier New; font-size:12px; width: auto!important; border: 1px solid; border-color:#b0b0b0; width:758px; height:auto; }
         .exdownbtn{
             width:250px; height:30px; float:left; position: relative; cursor:pointer; font-weight:bold; font-size:10px;
             line-height:30px; text-align: center; border-width:5px; background-color:#e1e1e1; color:#5c5a5a;
             border:4px solid #898888; font-family: grixel_acme_7_wide_xtnd, Courier New, Verdana, Arial;
         }
         .exdownbtn:hover{background-color:#f0d6d6; color:#c55757; border:4px solid #e66666;}
         #core pre code{border:10px solid; border-color:#888888; background-color:#dbdbe1; }
         #shapes pre code{border:10px solid; border-color:#e66666; background-color:#e9d0d6; }
         #textures pre code{border:10px solid; border-color:#75a06d; background-color:#c3e4bf; }
         #text pre code{border:10px solid; border-color:#52b296; background-color:#b9e9dd; }
         #models pre code{border:10px solid; border-color:#5d9cbd; background-color:#b9d6e8; }
         #audio pre code{border:10px solid; border-color:#d3b157; background-color:#e5d7ae; }
         #structs pre code{border:10px solid; border-color:#d2c9c6; background-color:#f8f8ff;}
         #colors pre code{border:10px solid; border-color:#c6d2c6; background-color:#e9f1f2;}
         #logo{width:128px; height:128px; float:left; position:relative; background-image:url(../common/img/raylib_logo.png);}
         #header{position:relative; height:110px; width: 1000px;}
         #title, #plinks, #version{position:relative; float:left; margin:0px; margin-left:10px; margin-top:10px;}
         #plinks{color: gray;}
         #plinks a, #copyright a{color: gray; text-decoration:none;}
         #plinks a:hover{color: black;}
         #version {margin-top: 23px; width:500px;}
         #pcore{margin-bottom:-12px; margin-left:12px; color:#5c5a5a;}
         #pshapes{margin-bottom:-12px; margin-left:12px; color:#c55757;}
         #ptextures{margin-bottom:-12px; margin-left:12px; color:#60815a;}
         #ptext{margin-bottom:-12px; margin-left:12px; color:#377764;}
         #pmodels{margin-bottom:-12px; margin-left:12px; color:#417794;}
         #paudio{margin-bottom:-12px; margin-left:12px; color:#8c7539;}
         #pstructs{margin-bottom:-12px; margin-left:12px; color:#bcbccd;}
         #pcolors{margin-bottom:-12px; margin-left:12px; color:#bcbccd;}

         #fullgroup{
             display: grid;
             grid-column-gap: 20px;
             grid-template-columns: auto auto;
         }

         #copyright p{color:#8b8b8b; font-size:10px}
         #copyright a:hover{color:black;}

         #downpdf{text-decoration: none;color:#aaaaaa;}
         #downpdf:hover{color:#444;}
        </style>

        <script type="text/javascript">
         $(document).ready(function() {
             $.get('raylib_core.c', function(data) {
                 $('#core pre code').text(data);
                 $('#core pre code').each(function(i, e) {hljs.highlightBlock(e)});
             }, 'text');
             $.get('raylib_shapes.c', function(data) {
                 $('#shapes pre code').text(data);
                 $('#shapes pre code').each(function(i, e) {hljs.highlightBlock(e)});
             }, 'text');
             $.get('raylib_textures.c', function(data) {
                 $('#textures pre code').text(data);
                 $('#textures pre code').each(function(i, e) {hljs.highlightBlock(e)});
             }, 'text');
             $.get('raylib_text.c', function(data) {
                 $('#text pre code').text(data);
                 $('#text pre code').each(function(i, e) {hljs.highlightBlock(e)});
             }, 'text');
             $.get('raylib_models.c', function(data) {
                 $('#models pre code').text(data);
                 $('#models pre code').each(function(i, e) {hljs.highlightBlock(e)});
             }, 'text');
             $.get('raylib_audio.c', function(data) {
                 $('#audio pre code').text(data);
                 $('#audio pre code').each(function(i, e) {hljs.highlightBlock(e)});
             }, 'text');
             $.get('raylib_colors.c', function(data) {
                 $('#colors pre code').text(data);
                 $('#colors pre code').each(function(i, e) {hljs.highlightBlock(e)});
             }, 'text');
             $.get('raylib_structs.c', function(data) {
                 $('#structs pre code').text(data);
                 $('#structs pre code').each(function(i, e) {hljs.highlightBlock(e)});
             }, 'text');
         });
        </script>
    <style>
      body.shimeji-pinned iframe {
        pointer-events: none;
      }
      body.shimeji-select-ie {
        cursor: cell !important;
      }
      #shimeji-contextMenu::-webkit-scrollbar {
        width: 6px;
      }
      #shimeji-contextMenu::-webkit-scrollbar-thumb {
        background-color: rgba(30,30,30,0.6);
        border-radius: 3px;
      }
      #shimeji-contextMenu::-webkit-scrollbar-thumb:hover {
        background: #555;
      }
    </style><meta name="shimejiBrowserExtensionId" content="gohjpllcolmccldfdggmamodembldgpc" data-version="2.0.4"><style type="text/css">/* Copyright 2021 Google Inc. All Rights Reserved. */<br>.goog-te-banner-frame{left:0px;top:0px;height:39px;width:100%;z-index:10000001;position:fixed;border:none;border-bottom:1px solid #6b90da;margin:0;-moz-box-shadow:0 0 8px 1px #999999;-webkit-box-shadow:0 0 8px 1px #999999;box-shadow:0 0 8px 1px #999999;_position:absolute}.goog-te-menu-frame{z-index:10000002;position:fixed;border:none;-moz-box-shadow:0 3px 8px 2px #999999;-webkit-box-shadow:0 3px 8px 2px #999999;box-shadow:0 3px 8px 2px #999999;_position:absolute}.goog-te-ftab-frame{z-index:10000000;border:none;margin:0}.goog-te-gadget{font-family:arial;font-size:11px;color:#666;white-space:nowrap}.goog-te-gadget img{vertical-align:middle;border:none}.goog-te-gadget-simple{background-color:#fff;border-left:1px solid #d5d5d5;border-top:1px solid #9b9b9b;border-bottom:1px solid #e8e8e8;border-right:1px solid #d5d5d5;font-size:10pt;display:inline-block;padding-top:1px;padding-bottom:2px;cursor:pointer;zoom:1;*display:inline}.goog-te-gadget-icon{margin-left:2px;margin-right:2px;width:19px;height:19px;border:none;vertical-align:middle}.goog-te-combo{margin-left:4px;margin-right:4px;vertical-align:baseline;*vertical-align:middle}.goog-te-gadget .goog-te-combo{margin:4px 0}.goog-logo-link,.goog-logo-link:link,.goog-logo-link:visited,.goog-logo-link:hover,.goog-logo-link:active{font-size:12px;font-weight:bold;color:#444;text-decoration:none}.goog-te-banner .goog-logo-link,.goog-close-link{display:block;margin:0px 10px}.goog-te-banner .goog-logo-link{padding-top:2px;padding-left:4px}.goog-te-combo,.goog-te-banner *,.goog-te-ftab *,.goog-te-menu *,.goog-te-menu2 *,.goog-te-balloon *{font-family:arial;font-size:10pt}.goog-te-banner{margin:0;background-color:#e4effb;overflow:hidden}.goog-te-banner img{border:none}.goog-te-banner-content{color:#000}.goog-te-banner-content img{vertical-align:middle}.goog-te-banner-info{color:#666;vertical-align:top;margin-top:0px;font-size:7pt}.goog-te-banner-margin{width:8px}.goog-te-button{border-color:#e7e7e7;border-style:none solid solid none;border-width:0 1px 1px 0}.goog-te-button div{border-color:#cccccc #999999 #999999 #cccccc;border-right:1px solid #999999;border-style:solid;border-width:1px;height:20px}.goog-te-button button{background:transparent;border:none;cursor:pointer;height:20px;overflow:hidden;margin:0;vertical-align:top;white-space:nowrap}.goog-te-button button:active{background:none repeat scroll 0 0 #cccccc}.goog-te-ftab{margin:0px;background-color:#fff;white-space:nowrap}.goog-te-ftab-link{text-decoration:none;font-weight:bold;font-size:10pt;border:1px outset #888;padding:6px 10px;white-space:nowrap;position:absolute;left:0px;top:0px}.goog-te-ftab-link img{margin-left:2px;margin-right:2px;width:19px;height:19px;border:none;vertical-align:middle}.goog-te-ftab-link span{text-decoration:underline;margin-left:2px;margin-right:2px;vertical-align:middle}.goog-float-top .goog-te-ftab-link{padding:2px 2px;border-top-width:0px}.goog-float-bottom .goog-te-ftab-link{padding:2px 2px;border-bottom-width:0px}.goog-te-menu-value{text-decoration:none;color:#0000cc;white-space:nowrap;margin-left:4px;margin-right:4px}.goog-te-menu-value span{text-decoration:underline}.goog-te-menu-value img{margin-left:2px;margin-right:2px}.goog-te-gadget-simple .goog-te-menu-value{color:#000}.goog-te-gadget-simple .goog-te-menu-value span{text-decoration:none}.goog-te-menu{background-color:#ffffff;text-decoration:none;border:2px solid #c3d9ff;overflow-y:scroll;overflow-x:hidden;position:absolute;left:0;top:0}.goog-te-menu-item{padding:3px;text-decoration:none}.goog-te-menu-item,.goog-te-menu-item:link{color:#0000cc;background:#ffffff}.goog-te-menu-item:visited{color:#551a8b}.goog-te-menu-item:hover{background:#c3d9ff}.goog-te-menu-item:active{color:#0000cc}.goog-te-menu2{background-color:#ffffff;text-decoration:none;border:1px solid #6b90da;overflow:hidden;padding:4px}.goog-te-menu2-colpad{width:16px}.goog-te-menu2-separator{margin:6px 0;height:1px;background-color:#aaa;overflow:hidden}.goog-te-menu2-item div,.goog-te-menu2-item-selected div{padding:4px}.goog-te-menu2-item .indicator{display:none}.goog-te-menu2-item-selected .indicator{display:auto}.goog-te-menu2-item-selected .text{padding-left:4px;padding-right:4px}.goog-te-menu2-item,.goog-te-menu2-item-selected{text-decoration:none}.goog-te-menu2-item div,.goog-te-menu2-item:link div,.goog-te-menu2-item:visited div,.goog-te-menu2-item:active div{color:#0000cc;background:#ffffff}.goog-te-menu2-item:hover div{color:#ffffff;background:#3366cc}.goog-te-menu2-item-selected div,.goog-te-menu2-item-selected:link div,.goog-te-menu2-item-selected:visited div,.goog-te-menu2-item-selected:hover div,.goog-te-menu2-item-selected:active div{color:#000;font-weight:bold}.goog-te-balloon{background-color:#ffffff;overflow:hidden;padding:8px;border:none;-moz-border-radius:10px;border-radius:10px}.goog-te-balloon-frame{background-color:#ffffff;border:1px solid #6b90da;-moz-box-shadow:0 3px 8px 2px #999999;-webkit-box-shadow:0 3px 8px 2px #999999;box-shadow:0 3px 8px 2px #999999;-moz-border-radius:8px;border-radius:8px}.goog-te-balloon img{border:none}.goog-te-balloon-text{margin-top:6px}.goog-te-balloon-zippy{margin-top:6px;white-space:nowrap}.goog-te-balloon-zippy *{vertical-align:middle}.goog-te-balloon-zippy .minus{background-image:url(//www.google.com/images/zippy_minus_sm.gif)}.goog-te-balloon-zippy .plus{background-image:url(//www.google.com/images/zippy_plus_sm.gif)}.goog-te-balloon-zippy span{color:#00c;text-decoration:underline;cursor:pointer;margin:0 4px}.goog-te-balloon-form{margin:6px 0 0 0}.goog-te-balloon-form form{margin:0}.goog-te-balloon-form form textarea{margin-bottom:4px;width:100%}.goog-te-balloon-footer{margin:6px 0 4px 0}.goog-te-spinner-pos{z-index:1000;position:fixed;transition-delay:0.6s;left:-1000px;top:-1000px}.goog-te-spinner-animation{background:#ccc;display:flex;align-items:center;justify-content:center;width:104px;height:104px;border-radius:50px;background:#fff url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciLz4=) 50% 50% no-repeat;transition:all 0.6s ease-in-out;transform:scale(0.4);opacity:0}.goog-te-spinner-animation-show{transform:scale(0.5);opacity:1}.goog-te-spinner{margin:2px 0 0 2px;animation:goog-te-spinner-rotator 1.4s linear infinite}@keyframes goog-te-spinner-rotator{0%{transform:rotate(0deg)}100%{transform:rotate(270deg)}}.goog-te-spinner-path{stroke-dasharray:187;stroke-dashoffset:0;stroke:#4285f4;transform-origin:center;animation:goog-te-spinner-dash 1.4s ease-in-out infinite}@keyframes goog-te-spinner-dash{0%{stroke-dashoffset:187}50%{stroke-dashoffset:46.75;transform:rotate(135deg)}100%{stroke-dashoffset:187;transform:rotate(450deg)}}#goog-gt-tt html,#goog-gt-tt body,#goog-gt-tt div,#goog-gt-tt span,#goog-gt-tt iframe,#goog-gt-tt h1,#goog-gt-tt h2,#goog-gt-tt h3,#goog-gt-tt h4,#goog-gt-tt h5,#goog-gt-tt h6,#goog-gt-tt p,#goog-gt-tt a,#goog-gt-tt img,#goog-gt-tt ol,#goog-gt-tt ul,#goog-gt-tt li,#goog-gt-tt table,#goog-gt-tt form,#goog-gt-tt tbody,#goog-gt-tt tr,#goog-gt-tt td{margin:0;padding:0;border:0;font-size:100%;font:inherit;vertical-align:baseline;text-align:left;line-height:normal}#goog-gt-tt ol,#goog-gt-tt ul{list-style:none}#goog-gt-tt table{border-collapse:collapse;border-spacing:0}#goog-gt-tt caption,#goog-gt-tt th,#goog-gt-tt td{text-align:left;font-weight:normal}#goog-gt-tt input::-moz-focus-inner{border:0}div#goog-gt-tt{padding:10px 14px}#goog-gt-tt{color:#222;background-color:#ffffff;border:1px solid #eee;box-shadow:0 4px 16px rgba(0,0,0,.2);-moz-box-shadow:0 4px 16px rgba(0,0,0,.2);-webkit-box-shadow:0 4px 16px rgba(0,0,0,.2);display:none;font-family:arial;font-size:10pt;width:420px;padding:12px;position:absolute;z-index:10000}#goog-gt-tt .original-text,.gt-hl-layer{clear:both;font-size:10pt;position:relative;text-align:justify;width:100%}#goog-gt-tt .title{color:#999;font-family:arial,sans-serif;margin:4px 0;text-align:left}#goog-gt-tt .close-button{display:none}#goog-gt-tt .logo{float:left;margin:0px}#goog-gt-tt .activity-links{display:inline-block}#goog-gt-tt .started-activity-container{display:none;width:100%}#goog-gt-tt .activity-root{margin-top:20px}#goog-gt-tt .left{float:left}#goog-gt-tt .right{float:right}#goog-gt-tt .bottom{min-height:15px;position:relative;height:1%}#goog-gt-tt .status-message{background:-moz-linear-gradient(top,#29910d 0%,#20af0e 100%);background:-webkit-linear-gradient(top,#29910d 0%,#20af0e 100%);background:-o-linear-gradient(top,#29910d 0%,#20af0e 100%);background:-ms-linear-gradient(top,#29910d 0%,#20af0e 100%);background:linear-gradient(top,#29910d 0%,#20af0e 100%);background:#29910d;border-radius:4px;-moz-border-radius:4px;-webkit-border-radius:4px;box-shadow:inset 0px 2px 2px #1e6609;-moz-box-shadow:inset 0px 2px 2px #1e6609;-webkit-box-shadow:inset 0px 2px 2px #1e6609;color:white;font-size:9pt;font-weight:bolder;margin-top:12px;padding:6px;text-shadow:1px 1px 1px #1e6609}#goog-gt-tt .activity-link{color:#1155cc;cursor:pointer;font-family:arial;font-size:11px;margin-right:15px;text-decoration:none}#goog-gt-tt textarea{font-family:arial;resize:vertical;width:100%;margin-bottom:10px;-webkit-border-radius:1px;-moz-border-radius:1px;border-radius:1px;border:1px solid #d9d9d9;border-top:1px solid silver;font-size:13px;height:auto;overflow-y:auto;padding:1px}#goog-gt-tt textarea:focus{-webkit-box-shadow:inset 0 1px 2px rgba(0,0,0,0.3);-moz-box-shadow:inset 0 1px 2px rgba(0,0,0,0.3);box-shadow:inset 0 1px 2px rgba(0,0,0,0.3);border:1px solid #4d90fe;outline:none}#goog-gt-tt .activity-cancel{margin-right:10px}#goog-gt-tt .translate-form{min-height:25px;vertical-align:middle;padding-top:8px}#goog-gt-tt .translate-form .activity-form{margin-bottom:5px;margin-bottom:0px}#goog-gt-tt .translate-form .activity-form input{display:inline-block;min-width:54px;*min-width:70px;border:1px solid #dcdcdc;border:1px solid rgba(0,0,0,0.1);text-align:center;color:#444;font-size:11px;font-weight:bold;height:27px;outline:0;padding:0 8px;vertical-align:middle;line-height:27px;margin:0 16px 0 0;box-shadow:0 1px 2px rgba(0,0,0,.1);-moz-box-shadow:0 1px 2px rgba(0,0,0,.1);-webkit-box-shadow:0 1px 2px rgba(0,0,0,.1);-webkit-border-radius:2px;-moz-border-radius:2px;border-radius:2px;-webkit-transition:all 0.218s;-moz-transition:all 0.218s;-o-transition:all 0.218s;transition:all 0.218s;background-color:#f5f5f5;background-image:-webkit-gradient(linear,left top,left bottom,from(#f5f5f5),to(#f1f1f1));background-image:-webkit-linear-gradient(top,#f5f5f5,#f1f1f1);background-image:-moz-linear-gradient(top,#f5f5f5,#f1f1f1);background-image:-ms-linear-gradient(top,#f5f5f5,#f1f1f1);background-image:-o-linear-gradient(top,#f5f5f5,#f1f1f1);background-image:linear-gradient(top,#f5f5f5,#f1f1f1);-webkit-user-select:none;-moz-user-select:none;cursor:default}#goog-gt-tt .translate-form .activity-form input:hover{border:1px solid #c6c6c6;color:#222;-webkit-transition:all 0.0s;-moz-transition:all 0.0s;-o-transition:all 0.0s;transition:all 0.0s;background-color:#f8f8f8;background-image:-webkit-gradient(linear,left top,left bottom,from(#f8f8f8),to(#f1f1f1));background-image:-webkit-linear-gradient(top,#f8f8f8,#f1f1f1);background-image:-moz-linear-gradient(top,#f8f8f8,#f1f1f1);background-image:-ms-linear-gradient(top,#f8f8f8,#f1f1f1);background-image:-o-linear-gradient(top,#f8f8f8,#f1f1f1);background-image:linear-gradient(top,#f8f8f8,#f1f1f1)}#goog-gt-tt .translate-form .activity-form input:active{border:1px solid #c6c6c6;color:#333;background-color:#f6f6f6;background-image:-webkit-gradient(linear,left top,left bottom,from(#f6f6f6),to(#f1f1f1));background-image:-webkit-linear-gradient(top,#f6f6f6,#f1f1f1);background-image:-moz-linear-gradient(top,#f6f6f6,#f1f1f1);background-image:-ms-linear-gradient(top,#f6f6f6,#f1f1f1);background-image:-o-linear-gradient(top,#f6f6f6,#f1f1f1);background-image:linear-gradient(top,#f6f6f6,#f1f1f1)}#goog-gt-tt .translate-form .activity-form input:focus #goog-gt-tt .translate-form .activity-form input.focus #goog-gt-tt .translate-form .activity-form input:active,#goog-gt-tt .translate-form .activity-form input:focus:active,#goog-gt-tt .translate-form .activity-form input:.focus:active{box-shadow:inset 0 0 0 1px rgba(255,255,255,0.5);-webkit-box-shadow:inset 0 0 0 1px rgba(255,255,255,0.5);-moz-box-shadow:inset 0 0 0 1px rgba(255,255,255,0.5)}#goog-gt-tt .translate-form .activity-form input:focus,#goog-gt-tt .translate-form .activity-form input.focus{outline:none;border:1px solid #4d90fe;z-index:4!important}#goog-gt-tt .translate-form .activity-form input.selected{background-color:#eeeeee;background-image:-webkit-gradient(linear,left top,left bottom,from(#eeeeee),to(#e0e0e0));background-image:-webkit-linear-gradient(top,#eeeeee,#e0e0e0);background-image:-moz-linear-gradient(top,#eeeeee,#e0e0e0);background-image:-ms-linear-gradient(top,#eeeeee,#e0e0e0);background-image:-o-linear-gradient(top,#eeeeee,#e0e0e0);background-image:linear-gradient(top,#eeeeee,#e0e0e0);-webkit-box-shadow:inset 0px 1px 2px rgba(0,0,0,0.1);-moz-box-shadow:inset 0px 1px 2px rgba(0,0,0,0.1);box-shadow:inset 0px 1px 2px rgba(0,0,0,0.1);border:1px solid #ccc;color:#333}#goog-gt-tt .translate-form .activity-form input.activity-submit{color:white;border-color:#3079ed;background-color:#4d90fe;background-image:-webkit-gradient(linear,left top,left bottom,from(#4d90fe),to(#4787ed));background-image:-webkit-linear-gradient(top,#4d90fe,#4787ed);background-image:-moz-linear-gradient(top,#4d90fe,#4787ed);background-image:-ms-linear-gradient(top,#4d90fe,#4787ed);background-image:-o-linear-gradient(top,#4d90fe,#4787ed);background-image:linear-gradient(top,#4d90fe,#4787ed)}#goog-gt-tt .translate-form .activity-form input.activity-submit:hover #goog-gt-tt .translate-form .activity-form input.activity-submit:focus,#goog-gt-tt .translate-form .activity-form input.activity-submit.focus #goog-gt-tt .translate-form .activity-form input.activity-submit:active{border-color:#3079ed;background-color:#357ae8;background-image:-webkit-gradient(linear,left top,left bottom,from(#4d90fe),to(#357ae8));background-image:-webkit-linear-gradient(top,#4d90fe,#357ae8);background-image:-moz-linear-gradient(top,#4d90fe,#357ae8);background-image:-ms-linear-gradient(top,#4d90fe,#357ae8);background-image:-o-linear-gradient(top,#4d90fe,#357ae8);background-image:linear-gradient(top,#4d90fe,#357ae8)}#goog-gt-tt .translate-form .activity-form input.activity-submit:hover{box-shadow:inset 0 0 0 1px #fff,0px 1px 1px rgba(0,0,0,0.1);-webkit-box-shadow:inset 0 0 0 1px #fff,0px 1px 1px rgba(0,0,0,0.1);-moz-box-shadow:inset 0 0 0 1px #fff,0px 1px 1px rgba(0,0,0,0.1)}#goog-gt-tt .translate-form .activity-form input:focus,#goog-gt-tt .translate-form .activity-form input.focus,#goog-gt-tt .translate-form .activity-form input:active,#goog-gt-tt .translate-form .activity-form input:hover,#goog-gt-tt .translate-form .activity-form input.activity-submit:focus,#goog-gt-tt .translate-form .activity-form input.activity-submit.focus,#goog-gt-tt .translate-form .activity-form input.activity-submit:active,#goog-gt-tt .translate-form .activity-form input.activity-submit:hover{border-color:#3079ed}#goog-gt-tt .gray{color:#999;font-family:arial,sans-serif}#goog-gt-tt .alt-helper-text{color:#999;font-size:11px;font-family:arial,sans-serif;margin:15px 0px 5px 0px}#goog-gt-tt .alt-error-text{color:#800;display:none;font-size:9pt}.goog-text-highlight{background-color:#c9d7f1;-webkit-box-shadow:2px 2px 4px #9999aa;-moz-box-shadow:2px 2px 4px #9999aa;box-shadow:2px 2px 4px #9999aa;box-sizing:border-box;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;position:relative}#goog-gt-tt .alt-menu.goog-menu{background:#ffffff;border:1px solid #dddddd;-webkit-box-shadow:0px 3px 3px #888;-moz-box-shadow:0px 2px 20px #888;box-shadow:0px 2px 4px #99a;min-width:0;outline:none;padding:0;position:absolute;z-index:2000}#goog-gt-tt .alt-menu .goog-menuitem{cursor:pointer;padding:2px 5px 5px;margin-right:0px;border-style:none}#goog-gt-tt .alt-menu div.goog-menuitem:hover{background:#ddd}#goog-gt-tt .alt-menu .goog-menuitem h1{font-size:100%;font-weight:bold;margin:4px 0px}#goog-gt-tt .alt-menu .goog-menuitem strong{color:#345aad}#goog-gt-tt .goog-submenu-arrow{text-align:right;position:absolute;right:0;left:auto}#goog-gt-tt .goog-menuitem-rtl .goog-submenu-arrow{text-align:left;position:absolute;left:0;right:auto}#goog-gt-tt .gt-hl-text,#goog-gt-tt .trans-target-highlight{background-color:#f1ea00;border-radius:4px;-webkit-border-radius:4px;-moz-border-radius:4px;-moz-box-shadow:rgba(0,0,0,.5) 3px 3px 4px;-webkit-box-shadow:rgba(0,0,0,.5) 3px 3px 4px;box-shadow:rgba(0,0,0,.5) 3px 3px 4px;box-sizing:border-box;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;color:#f1ea00;cursor:pointer;margin:-2px -2px -2px -3px;padding:2px 2px 2px 3px;position:relative}#goog-gt-tt .trans-target-highlight{color:#222}#goog-gt-tt .gt-hl-layer{color:white;position:absolute!important}#goog-gt-tt .trans-target,#goog-gt-tt .trans-target .trans-target-highlight{background-color:#c9d7f1;border-radius:4px 4px 0px 0px;-webkit-border-radius:4px 4px 0px 0px;-moz-border-radius:4px 4px 0px 0px;-moz-box-shadow:rgba(0,0,0,.5) 3px 3px 4px;-webkit-box-shadow:rgba(0,0,0,.5) 3px 3px 4px;box-shadow:rgba(0,0,0,.5) 3px 3px 4px;box-sizing:border-box;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;cursor:pointer;margin:-2px -2px -2px -3px;padding:2px 2px 3px 3px;position:relative}#goog-gt-tt span:focus{outline:none}#goog-gt-tt .trans-edit{background-color:transparent;border:1px solid #4d90fe;border-radius:0em;-webkit-border-radius:0em;-moz-border-radius:0em;margin:-2px;padding:1px}#goog-gt-tt .gt-trans-highlight-l{border-left:2px solid red;margin-left:-2px}#goog-gt-tt .gt-trans-highlight-r{border-right:2px solid red;margin-right:-2px}#goog-gt-tt #alt-input{padding:2px}#goog-gt-tt #alt-input-text{font-size:11px;padding:2px 2px 3px;margin:0;background-color:#fff;color:#333;border:1px solid #d9d9d9;border-top:1px solid #c0c0c0;display:inline-block;vertical-align:top;height:21px;box-sizing:border-box;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;-webkit-border-radius:1px}#goog-gt-tt #alt-input-text:hover{border:1px solid #b9b9b9;border-top:1px solid #a0a0a0;-webkit-box-shadow:inset 0px 1px 2px rgba(0,0,0,0.1);-moz-box-shadow:inset 0px 1px 2px rgba(0,0,0,0.1);box-shadow:inset 0px 1px 2px rgba(0,0,0,0.1)}#goog-gt-tt #alt-input-text:focus{-webkit-box-shadow:inset 0px 1px 2px rgba(0,0,0,0.3);-moz-box-shadow:inset 0px 1px 2px rgba(0,0,0,0.3);box-shadow:inset 0px 1px 2px rgba(0,0,0,0.3);outline:none;border:1px solid #4d90fe}#goog-gt-tt #alt-input-submit{font-size:11px;padding:2px 6px 3px;margin:0 0 0 2px;height:21px}.goog-te-spinner-pos, #goog-gt-tt {display: none;}</style><style type="text/css">/* Copyright 2021 Google Inc. All Rights Reserved. */<br>.goog-te-banner-frame{left:0px;top:0px;height:39px;width:100%;z-index:10000001;position:fixed;border:none;border-bottom:1px solid #6b90da;margin:0;-moz-box-shadow:0 0 8px 1px #999999;-webkit-box-shadow:0 0 8px 1px #999999;box-shadow:0 0 8px 1px #999999;_position:absolute}.goog-te-menu-frame{z-index:10000002;position:fixed;border:none;-moz-box-shadow:0 3px 8px 2px #999999;-webkit-box-shadow:0 3px 8px 2px #999999;box-shadow:0 3px 8px 2px #999999;_position:absolute}.goog-te-ftab-frame{z-index:10000000;border:none;margin:0}.goog-te-gadget{font-family:arial;font-size:11px;color:#666;white-space:nowrap}.goog-te-gadget img{vertical-align:middle;border:none}.goog-te-gadget-simple{background-color:#fff;border-left:1px solid #d5d5d5;border-top:1px solid #9b9b9b;border-bottom:1px solid #e8e8e8;border-right:1px solid #d5d5d5;font-size:10pt;display:inline-block;padding-top:1px;padding-bottom:2px;cursor:pointer;zoom:1;*display:inline}.goog-te-gadget-icon{margin-left:2px;margin-right:2px;width:19px;height:19px;border:none;vertical-align:middle}.goog-te-combo{margin-left:4px;margin-right:4px;vertical-align:baseline;*vertical-align:middle}.goog-te-gadget .goog-te-combo{margin:4px 0}.goog-logo-link,.goog-logo-link:link,.goog-logo-link:visited,.goog-logo-link:hover,.goog-logo-link:active{font-size:12px;font-weight:bold;color:#444;text-decoration:none}.goog-te-banner .goog-logo-link,.goog-close-link{display:block;margin:0px 10px}.goog-te-banner .goog-logo-link{padding-top:2px;padding-left:4px}.goog-te-combo,.goog-te-banner *,.goog-te-ftab *,.goog-te-menu *,.goog-te-menu2 *,.goog-te-balloon *{font-family:arial;font-size:10pt}.goog-te-banner{margin:0;background-color:#e4effb;overflow:hidden}.goog-te-banner img{border:none}.goog-te-banner-content{color:#000}.goog-te-banner-content img{vertical-align:middle}.goog-te-banner-info{color:#666;vertical-align:top;margin-top:0px;font-size:7pt}.goog-te-banner-margin{width:8px}.goog-te-button{border-color:#e7e7e7;border-style:none solid solid none;border-width:0 1px 1px 0}.goog-te-button div{border-color:#cccccc #999999 #999999 #cccccc;border-right:1px solid #999999;border-style:solid;border-width:1px;height:20px}.goog-te-button button{background:transparent;border:none;cursor:pointer;height:20px;overflow:hidden;margin:0;vertical-align:top;white-space:nowrap}.goog-te-button button:active{background:none repeat scroll 0 0 #cccccc}.goog-te-ftab{margin:0px;background-color:#fff;white-space:nowrap}.goog-te-ftab-link{text-decoration:none;font-weight:bold;font-size:10pt;border:1px outset #888;padding:6px 10px;white-space:nowrap;position:absolute;left:0px;top:0px}.goog-te-ftab-link img{margin-left:2px;margin-right:2px;width:19px;height:19px;border:none;vertical-align:middle}.goog-te-ftab-link span{text-decoration:underline;margin-left:2px;margin-right:2px;vertical-align:middle}.goog-float-top .goog-te-ftab-link{padding:2px 2px;border-top-width:0px}.goog-float-bottom .goog-te-ftab-link{padding:2px 2px;border-bottom-width:0px}.goog-te-menu-value{text-decoration:none;color:#0000cc;white-space:nowrap;margin-left:4px;margin-right:4px}.goog-te-menu-value span{text-decoration:underline}.goog-te-menu-value img{margin-left:2px;margin-right:2px}.goog-te-gadget-simple .goog-te-menu-value{color:#000}.goog-te-gadget-simple .goog-te-menu-value span{text-decoration:none}.goog-te-menu{background-color:#ffffff;text-decoration:none;border:2px solid #c3d9ff;overflow-y:scroll;overflow-x:hidden;position:absolute;left:0;top:0}.goog-te-menu-item{padding:3px;text-decoration:none}.goog-te-menu-item,.goog-te-menu-item:link{color:#0000cc;background:#ffffff}.goog-te-menu-item:visited{color:#551a8b}.goog-te-menu-item:hover{background:#c3d9ff}.goog-te-menu-item:active{color:#0000cc}.goog-te-menu2{background-color:#ffffff;text-decoration:none;border:1px solid #6b90da;overflow:hidden;padding:4px}.goog-te-menu2-colpad{width:16px}.goog-te-menu2-separator{margin:6px 0;height:1px;background-color:#aaa;overflow:hidden}.goog-te-menu2-item div,.goog-te-menu2-item-selected div{padding:4px}.goog-te-menu2-item .indicator{display:none}.goog-te-menu2-item-selected .indicator{display:auto}.goog-te-menu2-item-selected .text{padding-left:4px;padding-right:4px}.goog-te-menu2-item,.goog-te-menu2-item-selected{text-decoration:none}.goog-te-menu2-item div,.goog-te-menu2-item:link div,.goog-te-menu2-item:visited div,.goog-te-menu2-item:active div{color:#0000cc;background:#ffffff}.goog-te-menu2-item:hover div{color:#ffffff;background:#3366cc}.goog-te-menu2-item-selected div,.goog-te-menu2-item-selected:link div,.goog-te-menu2-item-selected:visited div,.goog-te-menu2-item-selected:hover div,.goog-te-menu2-item-selected:active div{color:#000;font-weight:bold}.goog-te-balloon{background-color:#ffffff;overflow:hidden;padding:8px;border:none;-moz-border-radius:10px;border-radius:10px}.goog-te-balloon-frame{background-color:#ffffff;border:1px solid #6b90da;-moz-box-shadow:0 3px 8px 2px #999999;-webkit-box-shadow:0 3px 8px 2px #999999;box-shadow:0 3px 8px 2px #999999;-moz-border-radius:8px;border-radius:8px}.goog-te-balloon img{border:none}.goog-te-balloon-text{margin-top:6px}.goog-te-balloon-zippy{margin-top:6px;white-space:nowrap}.goog-te-balloon-zippy *{vertical-align:middle}.goog-te-balloon-zippy .minus{background-image:url(//www.google.com/images/zippy_minus_sm.gif)}.goog-te-balloon-zippy .plus{background-image:url(//www.google.com/images/zippy_plus_sm.gif)}.goog-te-balloon-zippy span{color:#00c;text-decoration:underline;cursor:pointer;margin:0 4px}.goog-te-balloon-form{margin:6px 0 0 0}.goog-te-balloon-form form{margin:0}.goog-te-balloon-form form textarea{margin-bottom:4px;width:100%}.goog-te-balloon-footer{margin:6px 0 4px 0}.goog-te-spinner-pos{z-index:1000;position:fixed;transition-delay:0.6s;left:-1000px;top:-1000px}.goog-te-spinner-animation{background:#ccc;display:flex;align-items:center;justify-content:center;width:104px;height:104px;border-radius:50px;background:#fff url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciLz4=) 50% 50% no-repeat;transition:all 0.6s ease-in-out;transform:scale(0.4);opacity:0}.goog-te-spinner-animation-show{transform:scale(0.5);opacity:1}.goog-te-spinner{margin:2px 0 0 2px;animation:goog-te-spinner-rotator 1.4s linear infinite}@keyframes goog-te-spinner-rotator{0%{transform:rotate(0deg)}100%{transform:rotate(270deg)}}.goog-te-spinner-path{stroke-dasharray:187;stroke-dashoffset:0;stroke:#4285f4;transform-origin:center;animation:goog-te-spinner-dash 1.4s ease-in-out infinite}@keyframes goog-te-spinner-dash{0%{stroke-dashoffset:187}50%{stroke-dashoffset:46.75;transform:rotate(135deg)}100%{stroke-dashoffset:187;transform:rotate(450deg)}}#goog-gt-tt html,#goog-gt-tt body,#goog-gt-tt div,#goog-gt-tt span,#goog-gt-tt iframe,#goog-gt-tt h1,#goog-gt-tt h2,#goog-gt-tt h3,#goog-gt-tt h4,#goog-gt-tt h5,#goog-gt-tt h6,#goog-gt-tt p,#goog-gt-tt a,#goog-gt-tt img,#goog-gt-tt ol,#goog-gt-tt ul,#goog-gt-tt li,#goog-gt-tt table,#goog-gt-tt form,#goog-gt-tt tbody,#goog-gt-tt tr,#goog-gt-tt td{margin:0;padding:0;border:0;font-size:100%;font:inherit;vertical-align:baseline;text-align:left;line-height:normal}#goog-gt-tt ol,#goog-gt-tt ul{list-style:none}#goog-gt-tt table{border-collapse:collapse;border-spacing:0}#goog-gt-tt caption,#goog-gt-tt th,#goog-gt-tt td{text-align:left;font-weight:normal}#goog-gt-tt input::-moz-focus-inner{border:0}div#goog-gt-tt{padding:10px 14px}#goog-gt-tt{color:#222;background-color:#ffffff;border:1px solid #eee;box-shadow:0 4px 16px rgba(0,0,0,.2);-moz-box-shadow:0 4px 16px rgba(0,0,0,.2);-webkit-box-shadow:0 4px 16px rgba(0,0,0,.2);display:none;font-family:arial;font-size:10pt;width:420px;padding:12px;position:absolute;z-index:10000}#goog-gt-tt .original-text,.gt-hl-layer{clear:both;font-size:10pt;position:relative;text-align:justify;width:100%}#goog-gt-tt .title{color:#999;font-family:arial,sans-serif;margin:4px 0;text-align:left}#goog-gt-tt .close-button{display:none}#goog-gt-tt .logo{float:left;margin:0px}#goog-gt-tt .activity-links{display:inline-block}#goog-gt-tt .started-activity-container{display:none;width:100%}#goog-gt-tt .activity-root{margin-top:20px}#goog-gt-tt .left{float:left}#goog-gt-tt .right{float:right}#goog-gt-tt .bottom{min-height:15px;position:relative;height:1%}#goog-gt-tt .status-message{background:-moz-linear-gradient(top,#29910d 0%,#20af0e 100%);background:-webkit-linear-gradient(top,#29910d 0%,#20af0e 100%);background:-o-linear-gradient(top,#29910d 0%,#20af0e 100%);background:-ms-linear-gradient(top,#29910d 0%,#20af0e 100%);background:linear-gradient(top,#29910d 0%,#20af0e 100%);background:#29910d;border-radius:4px;-moz-border-radius:4px;-webkit-border-radius:4px;box-shadow:inset 0px 2px 2px #1e6609;-moz-box-shadow:inset 0px 2px 2px #1e6609;-webkit-box-shadow:inset 0px 2px 2px #1e6609;color:white;font-size:9pt;font-weight:bolder;margin-top:12px;padding:6px;text-shadow:1px 1px 1px #1e6609}#goog-gt-tt .activity-link{color:#1155cc;cursor:pointer;font-family:arial;font-size:11px;margin-right:15px;text-decoration:none}#goog-gt-tt textarea{font-family:arial;resize:vertical;width:100%;margin-bottom:10px;-webkit-border-radius:1px;-moz-border-radius:1px;border-radius:1px;border:1px solid #d9d9d9;border-top:1px solid silver;font-size:13px;height:auto;overflow-y:auto;padding:1px}#goog-gt-tt textarea:focus{-webkit-box-shadow:inset 0 1px 2px rgba(0,0,0,0.3);-moz-box-shadow:inset 0 1px 2px rgba(0,0,0,0.3);box-shadow:inset 0 1px 2px rgba(0,0,0,0.3);border:1px solid #4d90fe;outline:none}#goog-gt-tt .activity-cancel{margin-right:10px}#goog-gt-tt .translate-form{min-height:25px;vertical-align:middle;padding-top:8px}#goog-gt-tt .translate-form .activity-form{margin-bottom:5px;margin-bottom:0px}#goog-gt-tt .translate-form .activity-form input{display:inline-block;min-width:54px;*min-width:70px;border:1px solid #dcdcdc;border:1px solid rgba(0,0,0,0.1);text-align:center;color:#444;font-size:11px;font-weight:bold;height:27px;outline:0;padding:0 8px;vertical-align:middle;line-height:27px;margin:0 16px 0 0;box-shadow:0 1px 2px rgba(0,0,0,.1);-moz-box-shadow:0 1px 2px rgba(0,0,0,.1);-webkit-box-shadow:0 1px 2px rgba(0,0,0,.1);-webkit-border-radius:2px;-moz-border-radius:2px;border-radius:2px;-webkit-transition:all 0.218s;-moz-transition:all 0.218s;-o-transition:all 0.218s;transition:all 0.218s;background-color:#f5f5f5;background-image:-webkit-gradient(linear,left top,left bottom,from(#f5f5f5),to(#f1f1f1));background-image:-webkit-linear-gradient(top,#f5f5f5,#f1f1f1);background-image:-moz-linear-gradient(top,#f5f5f5,#f1f1f1);background-image:-ms-linear-gradient(top,#f5f5f5,#f1f1f1);background-image:-o-linear-gradient(top,#f5f5f5,#f1f1f1);background-image:linear-gradient(top,#f5f5f5,#f1f1f1);-webkit-user-select:none;-moz-user-select:none;cursor:default}#goog-gt-tt .translate-form .activity-form input:hover{border:1px solid #c6c6c6;color:#222;-webkit-transition:all 0.0s;-moz-transition:all 0.0s;-o-transition:all 0.0s;transition:all 0.0s;background-color:#f8f8f8;background-image:-webkit-gradient(linear,left top,left bottom,from(#f8f8f8),to(#f1f1f1));background-image:-webkit-linear-gradient(top,#f8f8f8,#f1f1f1);background-image:-moz-linear-gradient(top,#f8f8f8,#f1f1f1);background-image:-ms-linear-gradient(top,#f8f8f8,#f1f1f1);background-image:-o-linear-gradient(top,#f8f8f8,#f1f1f1);background-image:linear-gradient(top,#f8f8f8,#f1f1f1)}#goog-gt-tt .translate-form .activity-form input:active{border:1px solid #c6c6c6;color:#333;background-color:#f6f6f6;background-image:-webkit-gradient(linear,left top,left bottom,from(#f6f6f6),to(#f1f1f1));background-image:-webkit-linear-gradient(top,#f6f6f6,#f1f1f1);background-image:-moz-linear-gradient(top,#f6f6f6,#f1f1f1);background-image:-ms-linear-gradient(top,#f6f6f6,#f1f1f1);background-image:-o-linear-gradient(top,#f6f6f6,#f1f1f1);background-image:linear-gradient(top,#f6f6f6,#f1f1f1)}#goog-gt-tt .translate-form .activity-form input:focus #goog-gt-tt .translate-form .activity-form input.focus #goog-gt-tt .translate-form .activity-form input:active,#goog-gt-tt .translate-form .activity-form input:focus:active,#goog-gt-tt .translate-form .activity-form input:.focus:active{box-shadow:inset 0 0 0 1px rgba(255,255,255,0.5);-webkit-box-shadow:inset 0 0 0 1px rgba(255,255,255,0.5);-moz-box-shadow:inset 0 0 0 1px rgba(255,255,255,0.5)}#goog-gt-tt .translate-form .activity-form input:focus,#goog-gt-tt .translate-form .activity-form input.focus{outline:none;border:1px solid #4d90fe;z-index:4!important}#goog-gt-tt .translate-form .activity-form input.selected{background-color:#eeeeee;background-image:-webkit-gradient(linear,left top,left bottom,from(#eeeeee),to(#e0e0e0));background-image:-webkit-linear-gradient(top,#eeeeee,#e0e0e0);background-image:-moz-linear-gradient(top,#eeeeee,#e0e0e0);background-image:-ms-linear-gradient(top,#eeeeee,#e0e0e0);background-image:-o-linear-gradient(top,#eeeeee,#e0e0e0);background-image:linear-gradient(top,#eeeeee,#e0e0e0);-webkit-box-shadow:inset 0px 1px 2px rgba(0,0,0,0.1);-moz-box-shadow:inset 0px 1px 2px rgba(0,0,0,0.1);box-shadow:inset 0px 1px 2px rgba(0,0,0,0.1);border:1px solid #ccc;color:#333}#goog-gt-tt .translate-form .activity-form input.activity-submit{color:white;border-color:#3079ed;background-color:#4d90fe;background-image:-webkit-gradient(linear,left top,left bottom,from(#4d90fe),to(#4787ed));background-image:-webkit-linear-gradient(top,#4d90fe,#4787ed);background-image:-moz-linear-gradient(top,#4d90fe,#4787ed);background-image:-ms-linear-gradient(top,#4d90fe,#4787ed);background-image:-o-linear-gradient(top,#4d90fe,#4787ed);background-image:linear-gradient(top,#4d90fe,#4787ed)}#goog-gt-tt .translate-form .activity-form input.activity-submit:hover #goog-gt-tt .translate-form .activity-form input.activity-submit:focus,#goog-gt-tt .translate-form .activity-form input.activity-submit.focus #goog-gt-tt .translate-form .activity-form input.activity-submit:active{border-color:#3079ed;background-color:#357ae8;background-image:-webkit-gradient(linear,left top,left bottom,from(#4d90fe),to(#357ae8));background-image:-webkit-linear-gradient(top,#4d90fe,#357ae8);background-image:-moz-linear-gradient(top,#4d90fe,#357ae8);background-image:-ms-linear-gradient(top,#4d90fe,#357ae8);background-image:-o-linear-gradient(top,#4d90fe,#357ae8);background-image:linear-gradient(top,#4d90fe,#357ae8)}#goog-gt-tt .translate-form .activity-form input.activity-submit:hover{box-shadow:inset 0 0 0 1px #fff,0px 1px 1px rgba(0,0,0,0.1);-webkit-box-shadow:inset 0 0 0 1px #fff,0px 1px 1px rgba(0,0,0,0.1);-moz-box-shadow:inset 0 0 0 1px #fff,0px 1px 1px rgba(0,0,0,0.1)}#goog-gt-tt .translate-form .activity-form input:focus,#goog-gt-tt .translate-form .activity-form input.focus,#goog-gt-tt .translate-form .activity-form input:active,#goog-gt-tt .translate-form .activity-form input:hover,#goog-gt-tt .translate-form .activity-form input.activity-submit:focus,#goog-gt-tt .translate-form .activity-form input.activity-submit.focus,#goog-gt-tt .translate-form .activity-form input.activity-submit:active,#goog-gt-tt .translate-form .activity-form input.activity-submit:hover{border-color:#3079ed}#goog-gt-tt .gray{color:#999;font-family:arial,sans-serif}#goog-gt-tt .alt-helper-text{color:#999;font-size:11px;font-family:arial,sans-serif;margin:15px 0px 5px 0px}#goog-gt-tt .alt-error-text{color:#800;display:none;font-size:9pt}.goog-text-highlight{background-color:#c9d7f1;-webkit-box-shadow:2px 2px 4px #9999aa;-moz-box-shadow:2px 2px 4px #9999aa;box-shadow:2px 2px 4px #9999aa;box-sizing:border-box;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;position:relative}#goog-gt-tt .alt-menu.goog-menu{background:#ffffff;border:1px solid #dddddd;-webkit-box-shadow:0px 3px 3px #888;-moz-box-shadow:0px 2px 20px #888;box-shadow:0px 2px 4px #99a;min-width:0;outline:none;padding:0;position:absolute;z-index:2000}#goog-gt-tt .alt-menu .goog-menuitem{cursor:pointer;padding:2px 5px 5px;margin-right:0px;border-style:none}#goog-gt-tt .alt-menu div.goog-menuitem:hover{background:#ddd}#goog-gt-tt .alt-menu .goog-menuitem h1{font-size:100%;font-weight:bold;margin:4px 0px}#goog-gt-tt .alt-menu .goog-menuitem strong{color:#345aad}#goog-gt-tt .goog-submenu-arrow{text-align:right;position:absolute;right:0;left:auto}#goog-gt-tt .goog-menuitem-rtl .goog-submenu-arrow{text-align:left;position:absolute;left:0;right:auto}#goog-gt-tt .gt-hl-text,#goog-gt-tt .trans-target-highlight{background-color:#f1ea00;border-radius:4px;-webkit-border-radius:4px;-moz-border-radius:4px;-moz-box-shadow:rgba(0,0,0,.5) 3px 3px 4px;-webkit-box-shadow:rgba(0,0,0,.5) 3px 3px 4px;box-shadow:rgba(0,0,0,.5) 3px 3px 4px;box-sizing:border-box;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;color:#f1ea00;cursor:pointer;margin:-2px -2px -2px -3px;padding:2px 2px 2px 3px;position:relative}#goog-gt-tt .trans-target-highlight{color:#222}#goog-gt-tt .gt-hl-layer{color:white;position:absolute!important}#goog-gt-tt .trans-target,#goog-gt-tt .trans-target .trans-target-highlight{background-color:#c9d7f1;border-radius:4px 4px 0px 0px;-webkit-border-radius:4px 4px 0px 0px;-moz-border-radius:4px 4px 0px 0px;-moz-box-shadow:rgba(0,0,0,.5) 3px 3px 4px;-webkit-box-shadow:rgba(0,0,0,.5) 3px 3px 4px;box-shadow:rgba(0,0,0,.5) 3px 3px 4px;box-sizing:border-box;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;cursor:pointer;margin:-2px -2px -2px -3px;padding:2px 2px 3px 3px;position:relative}#goog-gt-tt span:focus{outline:none}#goog-gt-tt .trans-edit{background-color:transparent;border:1px solid #4d90fe;border-radius:0em;-webkit-border-radius:0em;-moz-border-radius:0em;margin:-2px;padding:1px}#goog-gt-tt .gt-trans-highlight-l{border-left:2px solid red;margin-left:-2px}#goog-gt-tt .gt-trans-highlight-r{border-right:2px solid red;margin-right:-2px}#goog-gt-tt #alt-input{padding:2px}#goog-gt-tt #alt-input-text{font-size:11px;padding:2px 2px 3px;margin:0;background-color:#fff;color:#333;border:1px solid #d9d9d9;border-top:1px solid #c0c0c0;display:inline-block;vertical-align:top;height:21px;box-sizing:border-box;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;-webkit-border-radius:1px}#goog-gt-tt #alt-input-text:hover{border:1px solid #b9b9b9;border-top:1px solid #a0a0a0;-webkit-box-shadow:inset 0px 1px 2px rgba(0,0,0,0.1);-moz-box-shadow:inset 0px 1px 2px rgba(0,0,0,0.1);box-shadow:inset 0px 1px 2px rgba(0,0,0,0.1)}#goog-gt-tt #alt-input-text:focus{-webkit-box-shadow:inset 0px 1px 2px rgba(0,0,0,0.3);-moz-box-shadow:inset 0px 1px 2px rgba(0,0,0,0.3);box-shadow:inset 0px 1px 2px rgba(0,0,0,0.3);outline:none;border:1px solid #4d90fe}#goog-gt-tt #alt-input-submit{font-size:11px;padding:2px 6px 3px;margin:0 0 0 2px;height:21px}.goog-te-spinner-pos, #goog-gt-tt {display: none;}</style></head>

    <body>
        
        <br>
        
        <div id="fulldata">
            <p id="pcore"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">модуль: rcore</font></font></p>
            <div id="core"><pre><code class="cpp hljs ">
    <span class="hljs-comment">// Функции, связанные с окном</span>
    <span class="hljs-keyword">void</span> InitWindow(<span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *title);  <span class="hljs-comment">// Инициализируем окно и контекст OpenGL</span>
    <span class="hljs-keyword">void</span> CloseWindow(<span class="hljs-keyword">void</span>);                                     <span class="hljs-comment">// Закрываем окно и выгружаем контекст OpenGL</span>
    <span class="hljs-keyword">bool</span> WindowShouldClose(<span class="hljs-keyword">void</span>);                               <span class="hljs-comment">// Check if application should close (KEY_ESCAPE pressed or windows close icon clicked)</span>
    <span class="hljs-keyword">bool</span> IsWindowReady(<span class="hljs-keyword">void</span>);                                   <span class="hljs-comment">// Проверяем, успешно ли инициализировано окно</span>
    <span class="hljs-keyword">bool</span> IsWindowFullscreen(<span class="hljs-keyword">void</span>);                              <span class="hljs-comment">// Проверяем, находится ли окно в полноэкранном режиме</span>
    <span class="hljs-keyword">bool</span> IsWindowHidden(<span class="hljs-keyword">void</span>);                                  <span class="hljs-comment">// Проверяем, скрыто ли окно в данный момент (только PLATFORM_DESKTOP)</span>
    <span class="hljs-keyword">bool</span> IsWindowMinimized(<span class="hljs-keyword">void</span>);                               <span class="hljs-comment">// Проверяем, свернуто ли окно в данный момент (только PLATFORM_DESKTOP)</span>
    <span class="hljs-keyword">bool</span> IsWindowMaximized(<span class="hljs-keyword">void</span>);                               <span class="hljs-comment">// Проверяем, развернуто ли окно в данный момент (только PLATFORM_DESKTOP)</span>
    <span class="hljs-keyword">bool</span> IsWindowFocused(<span class="hljs-keyword">void</span>);                                 <span class="hljs-comment">// Проверяем, в фокусе ли окно в данный момент (только PLATFORM_DESKTOP)</span>
    <span class="hljs-keyword">bool</span> IsWindowResized(<span class="hljs-keyword">void</span>);                                 <span class="hljs-comment">// Проверяем, был ли изменен размер окна в последнем кадре</span>
    <span class="hljs-keyword">bool</span> IsWindowState(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> flag);                      <span class="hljs-comment">// Проверяем, включен ли специфический флаг окна</span>
    <span class="hljs-keyword">void</span> SetWindowState(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> flags);                    <span class="hljs-comment">// Устанавливаем состояние конфигурации окна с помощью флагов (только PLATFORM_DESKTOP)</span>
    <span class="hljs-keyword">void</span> ClearWindowState(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> flags);                  <span class="hljs-comment">// Очистить флаги состояния конфигурации окна</span>
    <span class="hljs-keyword">void</span> ToggleFullscreen(<span class="hljs-keyword">void</span>);                                <span class="hljs-comment">// Переключение состояния окна: полноэкранное/оконное (только PLATFORM_DESKTOP)</span>
    <span class="hljs-keyword">void</span> ToggleBorderlessWindowed(<span class="hljs-keyword">void</span>);                        <span class="hljs-comment">// Переключение состояния окна: окно без полей (только PLATFORM_DESKTOP)</span>
    <span class="hljs-keyword">void</span> MaximizeWindow(<span class="hljs-keyword">void</span>);                                  <span class="hljs-comment">// Установить состояние окна: развернуто, если можно изменить размер (только PLATFORM_DESKTOP)</span>
    <span class="hljs-keyword">void</span> MinimizeWindow(<span class="hljs-keyword">void</span>);                                  <span class="hljs-comment">// Установить состояние окна: свернуто, если можно изменить размер (только PLATFORM_DESKTOP)</span>
    <span class="hljs-keyword">void</span> RestoreWindow(<span class="hljs-keyword">void</span>);                                   <span class="hljs-comment">// Устанавливаем состояние окна: не свернуто/развернуто (только PLATFORM_DESKTOP)</span>
    <span class="hljs-keyword">void</span> SetWindowIcon(Image image);                            <span class="hljs-comment">// Установить значок для окна (одиночное изображение, RGBA 32 бит, только PLATFORM_DESKTOP)</span>
    <span class="hljs-keyword">void</span> SetWindowIcons(Image *images, <span class="hljs-keyword">int</span> count);              <span class="hljs-comment">// Установить значок для окна (несколько изображений, RGBA 32 бит, только PLATFORM_DESKTOP)</span>
    <span class="hljs-keyword">void</span> SetWindowTitle(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *title);                     <span class="hljs-comment">// Устанавливаем заголовок окна (только PLATFORM_DESKTOP и PLATFORM_WEB)</span>
    <span class="hljs-keyword">void</span> SetWindowPosition(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y);                       <span class="hljs-comment">// Устанавливаем положение окна на экране (только PLATFORM_DESKTOP)</span>
    <span class="hljs-keyword">void</span> SetWindowMonitor(<span class="hljs-keyword">int</span> monitor);                         <span class="hljs-comment">// Устанавливаем монитор для текущего окна</span>
    <span class="hljs-keyword">void</span> SetWindowMinSize(<span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height);               <span class="hljs-comment">// Устанавливаем минимальные размеры окна (для FLAG_WINDOW_RESIZABLE)</span>
    <span class="hljs-keyword">void</span> SetWindowMaxSize(<span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height);               <span class="hljs-comment">// Устанавливаем максимальные размеры окна (для FLAG_WINDOW_RESIZABLE)</span>
    <span class="hljs-keyword">void</span> SetWindowSize(<span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height);                  <span class="hljs-comment">// Устанавливаем размеры окна</span>
    <span class="hljs-keyword">void</span> SetWindowOpacity(<span class="hljs-keyword">float</span> opacity);                       <span class="hljs-comment">// Устанавливаем прозрачность окна [0.0f..1.0f] (только PLATFORM_DESKTOP)</span>
    <span class="hljs-keyword">void</span> SetWindowFocused(<span class="hljs-keyword">void</span>);                                <span class="hljs-comment">// Установить фокус на окно (только PLATFORM_DESKTOP)</span>
    <span class="hljs-keyword">void</span> *GetWindowHandle(<span class="hljs-keyword">void</span>);                                <span class="hljs-comment">// Получаем собственный дескриптор окна</span>
    <span class="hljs-keyword">int</span> GetScreenWidth(<span class="hljs-keyword">void</span>);                                   <span class="hljs-comment">// Получаем текущую ширину экрана</span>
    <span class="hljs-keyword">int</span> GetScreenHeight(<span class="hljs-keyword">void</span>);                                  <span class="hljs-comment">// Получаем текущую высоту экрана</span>
    <span class="hljs-keyword">int</span> GetRenderWidth(<span class="hljs-keyword">void</span>);                                   <span class="hljs-comment">// Получаем текущую ширину рендеринга (учитывает HiDPI)</span>
    <span class="hljs-keyword">int</span> GetRenderHeight(<span class="hljs-keyword">void</span>);                                  <span class="hljs-comment">// Получаем текущую высоту рендеринга (учитывает HiDPI)</span>
    <span class="hljs-keyword">int</span> GetMonitorCount(<span class="hljs-keyword">void</span>);                                  <span class="hljs-comment">// Получаем количество подключенных мониторов</span>
    <span class="hljs-keyword">int</span> GetCurrentMonitor(<span class="hljs-keyword">void</span>);                                <span class="hljs-comment">// Получаем текущий подключенный монитор</span>
    Vector2 GetMonitorPosition(<span class="hljs-keyword">int</span> monitor);                    <span class="hljs-comment">// Получаем указанное положение монитора</span>
    <span class="hljs-keyword">int</span> GetMonitorWidth(<span class="hljs-keyword">int</span> monitor);                           <span class="hljs-comment">// Получаем указанную ширину монитора (текущий видеорежим, используемый монитором)</span>
    <span class="hljs-keyword">int</span> GetMonitorHeight(<span class="hljs-keyword">int</span> monitor);                          <span class="hljs-comment">// Получаем указанную высоту монитора (текущий видеорежим, используемый монитором)</span>
    <span class="hljs-keyword">int</span> GetMonitorPhysicalWidth(<span class="hljs-keyword">int</span> monitor);                   <span class="hljs-comment">// Получаем указанную физическую ширину монитора в миллиметрах</span>
    <span class="hljs-keyword">int</span> GetMonitorPhysicalHeight(<span class="hljs-keyword">int</span> monitor);                  <span class="hljs-comment">// Получаем указанную физическую высоту монитора в миллиметрах</span>
    <span class="hljs-keyword">int</span> GetMonitorRefreshRate(<span class="hljs-keyword">int</span> monitor);                     <span class="hljs-comment">// Получаем указанную частоту обновления монитора</span>
    Vector2 GetWindowPosition(<span class="hljs-keyword">void</span>);                            <span class="hljs-comment">// Получаем положение окна XY на мониторе</span>
    Vector2 GetWindowScaleDPI(<span class="hljs-keyword">void</span>);                            <span class="hljs-comment">// Получаем коэффициент DPI масштаба окна</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *GetMonitorName(<span class="hljs-keyword">int</span> monitor);                    <span class="hljs-comment">// Получаем удобочитаемое имя указанного монитора в кодировке UTF-8</span>
    <span class="hljs-keyword">void</span> SetClipboardText(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *text);                    <span class="hljs-comment">// Устанавливаем текстовое содержимое буфера обмена</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *GetClipboardText(<span class="hljs-keyword">void</span>);                         <span class="hljs-comment">// Получаем текстовое содержимое буфера обмена</span>
    <span class="hljs-keyword">void</span> EnableEventWaiting(<span class="hljs-keyword">void</span>);                              <span class="hljs-comment">// Включаем ожидание событий в EndDrawing(), без автоматического опроса событий</span>
    <span class="hljs-keyword">void</span> DisableEventWaiting(<span class="hljs-keyword">void</span>);                             <span class="hljs-comment">// Отключаем ожидание событий на EndDrawing(), автоматический опрос событий</span><font></font>
<font></font>
    <span class="hljs-comment">// Функции, связанные с курсором</span>
    <span class="hljs-keyword">void</span> ShowCursor(<span class="hljs-keyword">void</span>);                                      <span class="hljs-comment">// Показывает курсор</span>
    <span class="hljs-keyword">void</span> HideCursor(<span class="hljs-keyword">void</span>);                                      <span class="hljs-comment">// Скрываем курсор</span>
    <span class="hljs-keyword">bool</span> IsCursorHidden(<span class="hljs-keyword">void</span>);                                  <span class="hljs-comment">// Проверяем, не виден ли курсор</span>
    <span class="hljs-keyword">void</span> EnableCursor(<span class="hljs-keyword">void</span>);                                    <span class="hljs-comment">// Включаем курсор (разблокируем курсор)</span>
    <span class="hljs-keyword">void</span> DisableCursor(<span class="hljs-keyword">void</span>);                                   <span class="hljs-comment">// Отключает курсор (блокирует курсор)</span>
    <span class="hljs-keyword">bool</span> IsCursorOnScreen(<span class="hljs-keyword">void</span>);                                <span class="hljs-comment">// Проверяем, находится ли курсор на экране</span><font></font>
<font></font>
    <span class="hljs-comment">// Функции, связанные с рисованием</span>
    <span class="hljs-keyword">void</span> ClearBackground(Color color);                          <span class="hljs-comment">// Устанавливаем цвет фона (цвет очистки кадрового буфера)</span>
    <span class="hljs-keyword">void</span> BeginDrawing(<span class="hljs-keyword">void</span>);                                    <span class="hljs-comment">// Настройка холста (фреймбуфера) для начала рисования</span>
    <span class="hljs-keyword">void</span> EndDrawing(<span class="hljs-keyword">void</span>);                                      <span class="hljs-comment">// Завершаем рисование холста и меняем буферы (двойная буферизация)</span>
    <span class="hljs-keyword">void</span> BeginMode2D(Camera2D camera);                          <span class="hljs-comment">// Начинаем 2D-режим с пользовательской камерой (2D)</span>
    <span class="hljs-keyword">void</span> EndMode2D(<span class="hljs-keyword">void</span>);                                       <span class="hljs-comment">// Завершаем 2D-режим с пользовательской камерой</span>
    <span class="hljs-keyword">void</span> BeginMode3D(Camera3D camera);                          <span class="hljs-comment">// Начинаем 3D-режим с пользовательской камерой (3D)</span>
    <span class="hljs-keyword">void</span> EndMode3D(<span class="hljs-keyword">void</span>);                                       <span class="hljs-comment">// Завершаем 3D-режим и возвращаемся в ортогональный 2D-режим по умолчанию</span>
    <span class="hljs-keyword">void</span> BeginTextureMode(RenderTexture2D target);              <span class="hljs-comment">// Начинаем рисовать для рендеринга текстуры</span>
    <span class="hljs-keyword">void</span> EndTextureMode(<span class="hljs-keyword">void</span>);                                  <span class="hljs-comment">// Завершаем рисование для рендеринга текстуры</span>
    <span class="hljs-keyword">void</span> BeginShaderMode(Shader shader);                        <span class="hljs-comment">// Начинаем отрисовку пользовательского шейдера</span>
    <span class="hljs-keyword">void</span> EndShaderMode(<span class="hljs-keyword">void</span>);                                   <span class="hljs-comment">// Завершаем рисование пользовательского шейдера (используем шейдер по умолчанию)</span>
    <span class="hljs-keyword">void</span> BeginBlendMode(<span class="hljs-keyword">int</span> mode);                              <span class="hljs-comment">// Начинаем режим наложения (альфа, сложение, умножение, вычитание, пользовательский)</span>
    <span class="hljs-keyword">void</span> EndBlendMode(<span class="hljs-keyword">void</span>);                                    <span class="hljs-comment">// Завершаем режим смешивания (сбрасываем настройки по умолчанию: альфа-смешение)</span>
    <span class="hljs-keyword">void</span> BeginScissorMode(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height); <span class="hljs-comment">// Начать режим ножниц (определить область экрана для следующего рисунка)</span>
    <span class="hljs-keyword">void</span> EndScissorMode(<span class="hljs-keyword">void</span>);                                  <span class="hljs-comment">// Завершаем режим ножниц</span>
    <span class="hljs-keyword">void</span> BeginVrStereoMode(VrStereoConfig config);              <span class="hljs-comment">// Начинаем стереорендеринг (требуется симулятор VR)</span>
    <span class="hljs-keyword">void</span> EndVrStereoMode(<span class="hljs-keyword">void</span>);                                 <span class="hljs-comment">// Завершить стереорендеринг (требуется симулятор VR)</span><font></font>
<font></font>
    <span class="hljs-comment">// Функции конфигурации стерео VR для симулятора VR</span>
    VrStereoConfig LoadVrStereoConfig(VrDeviceInfo device);     <span class="hljs-comment">// Загрузка стереоконфигурации VR для параметров устройства симулятора VR</span>
    <span class="hljs-keyword">void</span> UnloadVrStereoConfig(VrStereoConfig config);           <span class="hljs-comment">// Выгружаем конфигурацию стерео VR</span><font></font>
<font></font>
    <span class="hljs-comment">// Функции управления шейдерами</span>
    <span class="hljs-comment">// ПРИМЕЧАНИЕ. Функциональность шейдеров недоступна в OpenGL 1.1.</span>
    Shader LoadShader(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *vsFileName, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fsFileName);   <span class="hljs-comment">// Загружаем шейдер из файлов и привязываем местоположения по умолчанию</span>
    Shader LoadShaderFromMemory(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *vsCode, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fsCode); <span class="hljs-comment">// Загружаем шейдер из строк кода и привязываем местоположения по умолчанию</span>
    <span class="hljs-keyword">bool</span> IsShaderReady(Shader shader);                                   <span class="hljs-comment">// Проверяем, готов ли шейдер</span>
    <span class="hljs-keyword">int</span> GetShaderLocation(Shader shader, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *uniformName);       <span class="hljs-comment">// Получаем местоположение шейдера</span>
    <span class="hljs-keyword">int</span> GetShaderLocationAttrib(Shader shader, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *attribName);  <span class="hljs-comment">// Получаем местоположение атрибута шейдера</span>
    <span class="hljs-keyword">void</span> SetShaderValue(Shader shader, <span class="hljs-keyword">int</span> locIndex, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *value, <span class="hljs-keyword">int</span> uniformType);               <span class="hljs-comment">// Устанавливаем однородное значение шейдера</span>
    <span class="hljs-keyword">void</span> SetShaderValueV(Shader shader, <span class="hljs-keyword">int</span> locIndex, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *value, <span class="hljs-keyword">int</span> uniformType, <span class="hljs-keyword">int</span> count);   <span class="hljs-comment">// Устанавливаем вектор унифицированных значений шейдера</span>
    <span class="hljs-keyword">void</span> SetShaderValueMatrix(Shader shader, <span class="hljs-keyword">int</span> locIndex, Matrix mat);         <span class="hljs-comment">// Устанавливаем однородное значение шейдера (матрица 4x4)</span>
    <span class="hljs-keyword">void</span> SetShaderValueTexture(Shader shader, <span class="hljs-keyword">int</span> locIndex, Texture2D texture); <span class="hljs-comment">// Устанавливаем однородное значение шейдера для текстуры (sampler2d)</span>
    <span class="hljs-keyword">void</span> UnloadShader(Shader shader);                                    <span class="hljs-comment">// Выгружаем шейдер из памяти графического процессора (VRAM)</span><font></font>
<font></font>
    <span class="hljs-comment">// Функции, связанные с экранным пространством</span>
    Ray GetMouseRay(Vector2 mousePosition, Camera camera);      <span class="hljs-comment">// Получаем трассировку лучей от позиции мыши</span>
    Matrix GetCameraMatrix(Camera camera);                      <span class="hljs-comment">// Получаем матрицу преобразования камеры (матрицу просмотра)</span>
    Matrix GetCameraMatrix2D(Camera2D camera);                  <span class="hljs-comment">// Получаем матрицу 2D-преобразования камеры</span>
    Vector2 GetWorldToScreen(Vector3 position, Camera camera);  <span class="hljs-comment">// Получаем позицию в пространстве экрана для позиции в 3D мировом пространстве</span>
    Vector2 GetScreenToWorld2D(Vector2 position, Camera2D camera); <span class="hljs-comment">// Получаем позицию в мировом пространстве для позиции 2D-экрана камеры</span>
    Vector2 GetWorldToScreenEx(Vector3 position, Camera camera, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height); <span class="hljs-comment">// Получаем позицию размера для позиции в 3D мировом пространстве</span>
    Vector2 GetWorldToScreen2D(Vector2 position, Camera2D camera); <span class="hljs-comment">// Получаем позицию в пространстве экрана для позиции 2D-камеры в мировом пространстве</span><font></font>
<font></font>
    <span class="hljs-comment">// Функции, связанные со временем</span>
    <span class="hljs-keyword">void</span> SetTargetFPS(<span class="hljs-keyword">int</span> fps);                                 <span class="hljs-comment">// Устанавливаем целевой FPS (максимум)</span>
    <span class="hljs-keyword">float</span> GetFrameTime(<span class="hljs-keyword">void</span>);                                   <span class="hljs-comment">// Получаем время в секундах для последнего нарисованного кадра (дельта времени)</span>
    <span class="hljs-keyword">double</span> GetTime(<span class="hljs-keyword">void</span>);                                       <span class="hljs-comment">// Получаем время в секундах, прошедшее с момента InitWindow()</span>
    <span class="hljs-keyword">int</span> GetFPS(<span class="hljs-keyword">void</span>);                                           <span class="hljs-comment">// Получаем текущий FPS</span><font></font>
<font></font>
    <span class="hljs-comment">// Пользовательские функции управления кадром</span>
    <span class="hljs-comment">// ПРИМЕЧАНИЕ. Эти функции предназначены для опытных пользователей, которым нужен полный контроль над обработкой кадров.</span>
    <span class="hljs-comment">// По умолчанию EndDrawing() выполняет эту работу: рисует все + SwapScreenBuffer() + управляет синхронизацией кадров + PollInputEvents()</span>
    <span class="hljs-comment">// Чтобы избежать такого поведения и управлять процессами фреймов вручную, включите в config.h: SUPPORT_CUSTOM_FRAME_CONTROL</span>
    <span class="hljs-keyword">void</span> SwapScreenBuffer(<span class="hljs-keyword">void</span>);                                <span class="hljs-comment">// Поменять местами задний буфер с передним буфером (отрисовка экрана)</span>
    <span class="hljs-keyword">void</span> PollInputEvents(<span class="hljs-keyword">void</span>);                                 <span class="hljs-comment">// Регистрируем все входные события</span>
    <span class="hljs-keyword">void</span> WaitTime(<span class="hljs-keyword">double</span> seconds);                              <span class="hljs-comment">// Подождем некоторое время (остановим выполнение программы)</span><font></font>
<font></font>
    <span class="hljs-comment">// Функции генерации случайных значений</span>
    <span class="hljs-keyword">void</span> SetRandomSeed(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> seed);                      <span class="hljs-comment">// Устанавливаем начальное значение для генератора случайных чисел</span>
    <span class="hljs-keyword">int</span> GetRandomValue(<span class="hljs-keyword">int</span> min, <span class="hljs-keyword">int</span> max);                       <span class="hljs-comment">// Получаем случайное значение между минимумом и максимумом (оба включены)</span>
    <span class="hljs-keyword">int</span> *LoadRandomSequence(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> count, <span class="hljs-keyword">int</span> min, <span class="hljs-keyword">int</span> max); <span class="hljs-comment">// Загружаем последовательность случайных значений, значения не повторяются</span>
    <span class="hljs-keyword">void</span> UnloadRandomSequence(<span class="hljs-keyword">int</span> *sequence);                   <span class="hljs-comment">// Выгружаем последовательность случайных значений</span><font></font>
<font></font>
    <span class="hljs-comment">// Другие функции</span>
    <span class="hljs-keyword">void</span> TakeScreenshot(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fileName);                  <span class="hljs-comment">// Делает снимок экрана текущего экрана (расширение имени файла определяет формат)</span>
    <span class="hljs-keyword">void</span> SetConfigFlags(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> flags);                    <span class="hljs-comment">// Установка флагов конфигурации инициализации (просмотр ФЛАГИ)</span>
    <span class="hljs-keyword">void</span> OpenURL(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *url);                              <span class="hljs-comment">// Открыть URL-адрес с помощью системного браузера по умолчанию (если доступен)</span><font></font>
<font></font>
    <span class="hljs-comment">// ПРИМЕЧАНИЕ. Следующие функции реализованы в модуле [utils]</span>
    <span class="hljs-comment">//------------------------------------------------------------------</span>
    <span class="hljs-keyword">void</span> TraceLog(<span class="hljs-keyword">int</span> logLevel, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *text, ...);         <span class="hljs-comment">// Показ сообщений журнала трассировки (LOG_DEBUG, LOG_INFO, LOG_WARNING, LOG_ERROR...)</span>
    <span class="hljs-keyword">void</span> SetTraceLogLevel(<span class="hljs-keyword">int</span> logLevel);                        <span class="hljs-comment">// Устанавливаем текущий пороговый (минимальный) уровень логирования</span>
    <span class="hljs-keyword">void</span> *MemAlloc(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> size);                          <span class="hljs-comment">// Распределитель внутренней памяти</span>
    <span class="hljs-keyword">void</span> *MemRealloc(<span class="hljs-keyword">void</span> *ptr, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> size);             <span class="hljs-comment">// Перераспределитель внутренней памяти</span>
    <span class="hljs-keyword">void</span> MemFree(<span class="hljs-keyword">void</span> *ptr);                                    <span class="hljs-comment">// Освобождение внутренней памяти</span><font></font>
<font></font>
    <span class="hljs-comment">// Установка пользовательских обратных вызовов</span>
    <span class="hljs-comment">// ВНИМАНИЕ: настройка обратных вызовов предназначена для опытных пользователей.</span>
    <span class="hljs-keyword">void</span> SetTraceLogCallback(TraceLogCallback callback);         <span class="hljs-comment">// Устанавливаем собственный журнал трассировки</span>
    <span class="hljs-keyword">void</span> SetLoadFileDataCallback(LoadFileDataCallback callback); <span class="hljs-comment">// Устанавливаем пользовательский загрузчик двоичных данных файла</span>
    <span class="hljs-keyword">void</span> SetSaveFileDataCallback(SaveFileDataCallback callback); <span class="hljs-comment">// Устанавливаем пользовательский файл сохранения двоичных данных</span>
    <span class="hljs-keyword">void</span> SetLoadFileTextCallback(LoadFileTextCallback callback); <span class="hljs-comment">// Устанавливаем пользовательский загрузчик текстовых данных файла</span>
    <span class="hljs-keyword">void</span> SetSaveFileTextCallback(SaveFileTextCallback callback); <span class="hljs-comment">// Установка пользовательского сохранения текстовых данных файла</span><font></font>
<font></font>
    <span class="hljs-comment">// Функции управления файлами</span>
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *LoadFileData(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fileName, <span class="hljs-keyword">int</span> *dataSize); <span class="hljs-comment">// Загружаем данные файла как массив байтов (чтение)</span>
    <span class="hljs-keyword">void</span> UnloadFileData(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *data);                   <span class="hljs-comment">// Выгружаем данные файла, выделенные функцией LoadFileData()</span>
    <span class="hljs-keyword">bool</span> SaveFileData(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fileName, <span class="hljs-keyword">void</span> *data, <span class="hljs-keyword">int</span> dataSize); <span class="hljs-comment">// Сохраняем данные в файл из байтового массива (запись), в случае успеха возвращает true</span>
    <span class="hljs-keyword">bool</span> ExportDataAsCode(<span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *data, <span class="hljs-keyword">int</span> dataSize, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fileName); <span class="hljs-comment">// Экспорт данных в код (.h), в случае успеха возвращает true</span>
    <span class="hljs-keyword">char</span> *LoadFileText(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fileName);                   <span class="hljs-comment">// Загрузка текстовых данных из файла (чтение), возвращает строку, завершающуюся '\0'</span>
    <span class="hljs-keyword">void</span> UnloadFileText(<span class="hljs-keyword">char</span> *text);                            <span class="hljs-comment">// Выгружаем текстовые данные файла, выделенные функцией LoadFileText()</span>
    <span class="hljs-keyword">bool</span> SaveFileText(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fileName, <span class="hljs-keyword">char</span> *text);        
<span class="hljs-comment">    // Сохраняем текстовые данные в файл (записываем), строка должна заканчиваться '\0', в случае успеха возвращает true</span>
    <span class="hljs-comment">//------------------------------------------------------------------</span><font></font>
<font></font>
    <span class="hljs-comment">// Функции файловой системы</span>
    <span class="hljs-keyword">bool</span> FileExists(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fileName);                      <span class="hljs-comment">// Проверяем, существует ли файл</span>
    <span class="hljs-keyword">bool</span> DirectoryExists(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *dirPath);                  <span class="hljs-comment">// Проверяем, существует ли путь к каталогу</span>
    <span class="hljs-keyword">bool</span> IsFileExtension(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fileName, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *ext); <span class="hljs-comment">// Проверка расширения файла (включая точку: .png, .wav)</span>
    <span class="hljs-keyword">int</span> GetFileLength(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fileName);                    <span class="hljs-comment">// Получаем длину файла в байтах (ПРИМЕЧАНИЕ: GetFileSize() конфликтует с windows.h)</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *GetFileExtension(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fileName);         <span class="hljs-comment">// Получаем указатель на расширение строки имени файла (включая точку: '.png')</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *GetFileName(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *filePath);              <span class="hljs-comment">// Получаем указатель на имя файла для строки пути</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *GetFileNameWithoutExt(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *filePath);    <span class="hljs-comment">// Получаем строку имени файла без расширения (использует статическую строку)</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *GetDirectoryPath(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *filePath);         <span class="hljs-comment">// Получить полный путь для данного имени файла с указанием пути (использует статическую строку)</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *GetPrevDirectoryPath(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *dirPath);      <span class="hljs-comment">// Получить путь к предыдущему каталогу для заданного пути (использует статическую строку)</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *GetWorkingDirectory(<span class="hljs-keyword">void</span>);                      <span class="hljs-comment">// Получаем текущий рабочий каталог (использует статическую строку)</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *GetApplicationDirectory(<span class="hljs-keyword">void</span>);                  <span class="hljs-comment">// Получаем каталог запущенного приложения (использует статическую строку)</span>
    <span class="hljs-keyword">bool</span> ChangeDirectory(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *dir);                      <span class="hljs-comment">// Изменяем рабочий каталог, в случае успеха возвращаем true</span>
    <span class="hljs-keyword">bool</span> IsPathFile(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path);                          <span class="hljs-comment">// Проверяем, является ли данный путь файлом или каталогом</span>
    FilePathList LoadDirectoryFiles(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *dirPath);       <span class="hljs-comment">// Загрузка путей к файлам каталогов</span>
    FilePathList LoadDirectoryFilesEx(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *basePath, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *filter, <span class="hljs-keyword">bool</span> scanSubdirs); 
<font></font><font></font><span class="hljs-comment">    // Load directory filepaths with extension filtering and recursive directory scan</span>
    <span class="hljs-keyword">void</span> UnloadDirectoryFiles(FilePathList files);              <span class="hljs-comment">// Выгружаем пути к файлам</span>
    <span class="hljs-keyword">bool</span> IsFileDropped(<span class="hljs-keyword">void</span>);                                   <span class="hljs-comment">// Проверяем, был ли файл переброшен в окно</span>
    FilePathList LoadDroppedFiles(<span class="hljs-keyword">void</span>);                        <span class="hljs-comment">// Загрузка переброшенных путей к файлам</span>
    <span class="hljs-keyword">void</span> UnloadDroppedFiles(FilePathList files);                <span class="hljs-comment">// Выгружаем переброшенных путей к файлам</span>
    <span class="hljs-keyword">long</span> GetFileModTime(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fileName);                  <span class="hljs-comment">// Получаем время модификации файла (время последней записи)</span><font></font>
<font></font>
    <span class="hljs-comment">// Функции сжатия/кодирования</span>
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *CompressData(<span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *data, <span class="hljs-keyword">int</span> dataSize, <span class="hljs-keyword">int</span> *compDataSize);        <span class="hljs-comment">// Сжатие данных (алгоритм DEFLATE), память должна быть MemFree()</span>
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *DecompressData(<span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *compData, <span class="hljs-keyword">int</span> compDataSize, <span class="hljs-keyword">int</span> *dataSize);  <span class="hljs-comment">// Распаковка данных (алгоритм DEFLATE), память должна быть MemFree()</span>
    <span class="hljs-keyword">char</span> *EncodeDataBase64(<span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *data, <span class="hljs-keyword">int</span> dataSize, <span class="hljs-keyword">int</span> *outputSize);               <span class="hljs-comment">// Кодируем данные в строку Base64, память должна быть MemFree()</span>
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *DecodeDataBase64(<span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *data, <span class="hljs-keyword">int</span> *outputSize);                    <span class="hljs-comment">// Декодируем строковые данные Base64, память должна быть MemFree()</span><font></font>
<font></font>
    <span class="hljs-comment">// Функции событий автоматизации</span>
    AutomationEventList LoadAutomationEventList(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fileName);                
<font></font><font></font> <span class="hljs-comment">    // Загружаем список событий автоматизации из файла, NULL для пустого списка, емкость = MAX_AUTOMATION_EVENTS</span>
    <span class="hljs-keyword">void</span> UnloadAutomationEventList(AutomationEventList *<span class="hljs-built_in">list</span>);                        <span class="hljs-comment">// Выгружаем список событий автоматизации из файла</span>
    <span class="hljs-keyword">bool</span> ExportAutomationEventList(AutomationEventList <span class="hljs-built_in">list</span>, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fileName);   <span class="hljs-comment">// Экспортируем список событий автоматизации в текстовый файл</span>
    <span class="hljs-keyword">void</span> SetAutomationEventList(AutomationEventList *<span class="hljs-built_in">list</span>);                           <span class="hljs-comment">// Устанавливаем список событий автоматизации для записи</span>
    <span class="hljs-keyword">void</span> SetAutomationEventBaseFrame(<span class="hljs-keyword">int</span> frame);                                      <span class="hljs-comment">// Устанавливаем внутренний базовый кадр события автоматизации для начала записи</span>
    <span class="hljs-keyword">void</span> StartAutomationEventRecording(<span class="hljs-keyword">void</span>);                                         <span class="hljs-comment">// Начинаем запись событий автоматизации (должен быть установлен AutomationEventList)</span>
    <span class="hljs-keyword">void</span> StopAutomationEventRecording(<span class="hljs-keyword">void</span>);                                          <span class="hljs-comment">// Остановка записи событий автоматизации</span>
    <span class="hljs-keyword">void</span> PlayAutomationEvent(AutomationEvent event);                                  <span class="hljs-comment">// Воспроизведение записанного события автоматизации</span><font></font>
<font></font>
    <span class="hljs-comment">//------------------------------------------------------------------------------------</span>
    <span class="hljs-comment">// Функции обработки ввода (Модуль: ядро)</span>
    <span class="hljs-comment">//------------------------------------------------------------------------------------</span><font></font>
<font></font>
    <span class="hljs-comment">// Функции, связанные с вводом: клавиатура</span>
    <span class="hljs-keyword">bool</span> IsKeyPressed(<span class="hljs-keyword">int</span> key);                             <span class="hljs-comment">// Проверяем, была ли клавиша нажата один раз</span>
    <span class="hljs-keyword">bool</span> IsKeyPressedRepeat(<span class="hljs-keyword">int</span> key);                       <span class="hljs-comment">// Проверяем, была ли клавиша нажата еще раз (только PLATFORM_DESKTOP)</span>
    <span class="hljs-keyword">bool</span> IsKeyDown(<span class="hljs-keyword">int</span> key);                                <span class="hljs-comment">// Проверяем, нажата ли клавиша</span>
    <span class="hljs-keyword">bool</span> IsKeyReleased(<span class="hljs-keyword">int</span> key);                            <span class="hljs-comment">// Проверяем, была ли клавиша отпущена</span>
    <span class="hljs-keyword">bool</span> IsKeyUp(<span class="hljs-keyword">int</span> key);                                  <span class="hljs-comment">// Проверяем, НЕ нажата ли клавиша</span>
    <span class="hljs-keyword">int</span> GetKeyPressed(<span class="hljs-keyword">void</span>);                                <span class="hljs-comment">// Получаем нажатие клавиши (код клавиши), вызываем его несколько раз для клавиш, находящихся в очереди, возвращает 0, когда очередь пуста</span>
    <span class="hljs-keyword">int</span> GetCharPressed(<span class="hljs-keyword">void</span>);                               <span class="hljs-comment">// Нажимаем символ (Юникод), вызываем его несколько раз для символов в очереди, возвращает 0, когда очередь пуста</span>
    <span class="hljs-keyword">void</span> SetExitKey(<span class="hljs-keyword">int</span> key);                               <span class="hljs-comment">// Установка пользовательской клавиши для выхода из программы (по умолчанию ESC)</span><font></font>
<font></font>
    <span class="hljs-comment">// Функции, связанные с вводом: геймпады</span>
    <span class="hljs-keyword">bool</span> IsGamepadAvailable(<span class="hljs-keyword">int</span> gamepad);                   <span class="hljs-comment">// Проверяем, доступен ли геймпад</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *GetGamepadName(<span class="hljs-keyword">int</span> gamepad);                <span class="hljs-comment">// Получаем идентификатор внутреннего имени геймпада</span>
    <span class="hljs-keyword">bool</span> IsGamepadButtonPressed(<span class="hljs-keyword">int</span> gamepad, <span class="hljs-keyword">int</span> button);   <span class="hljs-comment">// Проверяем, была ли нажата кнопка геймпада один раз</span>
    <span class="hljs-keyword">bool</span> IsGamepadButtonDown(<span class="hljs-keyword">int</span> gamepad, <span class="hljs-keyword">int</span> button);      <span class="hljs-comment">// Проверяем, нажата ли кнопка геймпада</span>
    <span class="hljs-keyword">bool</span> IsGamepadButtonReleased(<span class="hljs-keyword">int</span> gamepad, <span class="hljs-keyword">int</span> button);  <span class="hljs-comment">// Проверяем, была ли отпущена кнопка геймпада</span>
    <span class="hljs-keyword">bool</span> IsGamepadButtonUp(<span class="hljs-keyword">int</span> gamepad, <span class="hljs-keyword">int</span> button);        <span class="hljs-comment">// Проверяем, НЕ нажата ли кнопка геймпада</span>
    <span class="hljs-keyword">int</span> GetGamepadButtonPressed(<span class="hljs-keyword">void</span>);                      <span class="hljs-comment">// Получаем нажатие последней кнопки геймпада</span>
    <span class="hljs-keyword">int</span> GetGamepadAxisCount(<span class="hljs-keyword">int</span> gamepad);                   <span class="hljs-comment">// Получаем количество осей для геймпада</span>
    <span class="hljs-keyword">float</span> GetGamepadAxisMovement(<span class="hljs-keyword">int</span> gamepad, <span class="hljs-keyword">int</span> axis);    <span class="hljs-comment">// Получаем значение перемещения оси геймпада</span>
    <span class="hljs-keyword">int</span> SetGamepadMappings(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *mappings);           <span class="hljs-comment">// Устанавливаем внутренние сопоставления геймпада (SDL_GameControllerDB)</span><font></font>
<font></font>
    <span class="hljs-comment">// Функции, связанные с вводом: мышь</span>
    <span class="hljs-keyword">bool</span> IsMouseButtonPressed(<span class="hljs-keyword">int</span> button);                  <span class="hljs-comment">// Проверяем, была ли нажата кнопка мыши один раз</span>
    <span class="hljs-keyword">bool</span> IsMouseButtonDown(<span class="hljs-keyword">int</span> button);                     <span class="hljs-comment">// Проверяем, нажата ли кнопка мыши</span>
    <span class="hljs-keyword">bool</span> IsMouseButtonReleased(<span class="hljs-keyword">int</span> button);                 <span class="hljs-comment">// Проверяем, была ли отпущена кнопка мыши</span>
    <span class="hljs-keyword">bool</span> IsMouseButtonUp(<span class="hljs-keyword">int</span> button);                       <span class="hljs-comment">// Проверяем, НЕ нажата ли кнопка мыши</span>
    <span class="hljs-keyword">int</span> GetMouseX(<span class="hljs-keyword">void</span>);                                    <span class="hljs-comment">// Получаем позицию мыши X</span>
    <span class="hljs-keyword">int</span> GetMouseY(<span class="hljs-keyword">void</span>);                                    <span class="hljs-comment">// Получаем позицию мыши Y</span>
    Vector2 GetMousePosition(<span class="hljs-keyword">void</span>);                         <span class="hljs-comment">// Получаем позицию мыши XY</span>
    Vector2 GetMouseDelta(<span class="hljs-keyword">void</span>);                            <span class="hljs-comment">// Получаем разницу позиции мыши между кадрами</span>
    <span class="hljs-keyword">void</span> SetMousePosition(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y);                    <span class="hljs-comment">// Устанавливаем положение мыши XY</span>
    <span class="hljs-keyword">void</span> SetMouseOffset(<span class="hljs-keyword">int</span> offsetX, <span class="hljs-keyword">int</span> offsetY);          <span class="hljs-comment">// Устанавливаем смещение положения мыши</span>
    <span class="hljs-keyword">void</span> SetMouseScale(<span class="hljs-keyword">float</span> scaleX, <span class="hljs-keyword">float</span> scaleY);         <span class="hljs-comment">// Устанавливаем масштаб перемещения мыши</span>
    <span class="hljs-keyword">float</span> GetMouseWheelMove(<span class="hljs-keyword">void</span>);                          <span class="hljs-comment">// Получаем движение колеса мыши по X или Y, в зависимости от того, что больше</span>
    Vector2 GetMouseWheelMoveV(<span class="hljs-keyword">void</span>);                       <span class="hljs-comment">// Получаем движение колеса мыши для X и Y</span>
    <span class="hljs-keyword">void</span> SetMouseCursor(<span class="hljs-keyword">int</span> cursor);                        <span class="hljs-comment">// Устанавливаем курсор мыши</span><font></font>
<font></font>
    <span class="hljs-comment">// Функции, связанные с вводом: касание</span>
    <span class="hljs-keyword">int</span> GetTouchX(<span class="hljs-keyword">void</span>);                                    <span class="hljs-comment">// Получаем позицию касания X для точки касания 0 (относительно размера экрана)</span>
    <span class="hljs-keyword">int</span> GetTouchY(<span class="hljs-keyword">void</span>);                                    <span class="hljs-comment">// Получаем позицию касания Y для точки касания 0 (относительно размера экрана)</span>
    Vector2 GetTouchPosition(<span class="hljs-keyword">int</span> index);                    <span class="hljs-comment">// Получаем позицию касания XY для индекса точки касания (относительно размера экрана)</span>
    <span class="hljs-keyword">int</span> GetTouchPointId(<span class="hljs-keyword">int</span> index);                         <span class="hljs-comment">// Получаем идентификатор точки касания для данного индекса</span>
    <span class="hljs-keyword">int</span> GetTouchPointCount(<span class="hljs-keyword">void</span>);                           <span class="hljs-comment">// Получаем количество точек касания</span><font></font>
<font></font>
    <span class="hljs-comment">//------------------------------------------------------------------------------------</span>
    <span class="hljs-comment">// Функции жестов и обработки сенсорного ввода (Модуль: rgestures)</span>
    <span class="hljs-comment">//------------------------------------------------------------------------------------</span>
    <span class="hljs-keyword">void</span> SetGesturesEnabled(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> flags);      <span class="hljs-comment">// Включаем набор жестов с помощью флагов</span>
    <span class="hljs-keyword">bool</span> IsGestureDetected(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> gesture);     <span class="hljs-comment">// Проверяем, обнаружен ли жест</span>
    <span class="hljs-keyword">int</span> GetGestureDetected(<span class="hljs-keyword">void</span>);                     <span class="hljs-comment">// Получить последний обнаруженный жест</span>
    <span class="hljs-keyword">float</span> GetGestureHoldDuration(<span class="hljs-keyword">void</span>);               <span class="hljs-comment">// Получаем время удержания жеста в миллисекундах</span>
    Vector2 GetGestureDragVector(<span class="hljs-keyword">void</span>);               <span class="hljs-comment">// Получаем вектор перетаскивания жеста</span>
    <span class="hljs-keyword">float</span> GetGestureDragAngle(<span class="hljs-keyword">void</span>);                  <span class="hljs-comment">// Получаем угол перетаскивания жеста</span>
    Vector2 GetGesturePinchVector(<span class="hljs-keyword">void</span>);              <span class="hljs-comment">// Получаем дельту жеста</span>
    <span class="hljs-keyword">float</span> GetGesturePinchAngle(<span class="hljs-keyword">void</span>);                 <span class="hljs-comment">// Получаем угол сжатия жеста</span><font></font>
<font></font>
    <span class="hljs-comment">//------------------------------------------------------------------------------------</span>
    <span class="hljs-comment">// Системные функции камеры (Модуль: rcamera)</span>
    <span class="hljs-comment">//------------------------------------------------------------------------------------</span>
    <span class="hljs-keyword">void</span> UpdateCamera(Camera *camera, <span class="hljs-keyword">int</span> mode);      <span class="hljs-comment">// Обновляем положение камеры для выбранного режима</span>
    <span class="hljs-keyword">void</span> UpdateCameraPro(Camera *camera, Vector3 movement, Vector3 rotation, <span class="hljs-keyword">float</span> zoom); <span class="hljs-comment">// Обновляем движение/вращение камеры</span><font></font>
<font></font>
</code></pre></div>
            <p id="pshapes"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">модуль: rshapes</font></font></p>
            <div id="shapes"><pre><code class="cpp hljs ">    <span class="hljs-comment">// ПРИМЕЧАНИЕ. Это может быть полезно при использовании основных фигур и одного шрифта,</span>
    <span class="hljs-comment">// определение белого прямоугольника шрифта char позволит рисовать все за один вызов отрисовки</span>
    <span class="hljs-keyword">void</span> SetShapesTexture(Texture2D texture, Rectangle source);       <span class="hljs-comment">// Устанавливаем текстуру и прямоугольник, которые будут использоваться при рисовании фигур</span><font></font>
<font></font>
    <span class="hljs-comment">// Основные функции рисования фигур</span>
    <span class="hljs-keyword">void</span> DrawPixel(<span class="hljs-keyword">int</span> posX, <span class="hljs-keyword">int</span> posY, Color color);                                                   <span class="hljs-comment">// Рисуем пиксель</span>
    <span class="hljs-keyword">void</span> DrawPixelV(Vector2 position, Color color);                                                    <span class="hljs-comment">// Рисуем пиксель (Векторная версия)</span>
    <span class="hljs-keyword">void</span> DrawLine(<span class="hljs-keyword">int</span> startPosX, <span class="hljs-keyword">int</span> startPosY, <span class="hljs-keyword">int</span> endPosX, <span class="hljs-keyword">int</span> endPosY, Color color);                <span class="hljs-comment">// Рисуем линию</span>
    <span class="hljs-keyword">void</span> DrawLineV(Vector2 startPos, Vector2 endPos, Color color);                                     <span class="hljs-comment">// Рисуем линию (используя линии gl)</span>
    <span class="hljs-keyword">void</span> DrawLineEx(Vector2 startPos, Vector2 endPos, <span class="hljs-keyword">float</span> thick, Color color);                       <span class="hljs-comment">// Рисуем линию (используя треугольники/квадратики)</span>
    <span class="hljs-keyword">void</span> DrawLineStrip(Vector2 *points, <span class="hljs-keyword">int</span> pointCount, Color color);                                  <span class="hljs-comment">// Рисуем последовательность линий (используя линии gl)</span>
    <span class="hljs-keyword">void</span> DrawLineBezier(Vector2 startPos, Vector2 endPos, <span class="hljs-keyword">float</span> thick, Color color);                   <font></font> 
<span class="hljs-comment">    // Рисование сегмента линии с кубической кривизной Безье, интерполяция вход-выход</span>
    <span class="hljs-keyword">void</span> DrawCircle(<span class="hljs-keyword">int</span> centerX, <span class="hljs-keyword">int</span> centerY, <span class="hljs-keyword">float</span> radius, Color color);                              <span class="hljs-comment">// Рисуем круг, закрашенный цветом</span>
    <span class="hljs-keyword">void</span> DrawCircleSector(Vector2 center, <span class="hljs-keyword">float</span> radius, <span class="hljs-keyword">float</span> startAngle, <span class="hljs-keyword">float</span> endAngle, <span class="hljs-keyword">int</span> segments, Color color);      <span class="hljs-comment">// Рисуем часть круга</span>
    <span class="hljs-keyword">void</span> DrawCircleSectorLines(Vector2 center, <span class="hljs-keyword">float</span> radius, <span class="hljs-keyword">float</span> startAngle, <span class="hljs-keyword">float</span> endAngle, <span class="hljs-keyword">int</span> segments, Color color); <span class="hljs-comment">// Рисуем контур сектора круга</span>
    <span class="hljs-keyword">void</span> DrawCircleGradient(<span class="hljs-keyword">int</span> centerX, <span class="hljs-keyword">int</span> centerY, <span class="hljs-keyword">float</span> radius, Color color1, Color color2);       <span class="hljs-comment">// Рисуем круг с градиентной заливкой</span>
    <span class="hljs-keyword">void</span> DrawCircleV(Vector2 center, <span class="hljs-keyword">float</span> radius, Color color);                                       <span class="hljs-comment">// Рисуем закрашенный круг (векторная версия)</span>
    <span class="hljs-keyword">void</span> DrawCircleLines(<span class="hljs-keyword">int</span> centerX, <span class="hljs-keyword">int</span> centerY, <span class="hljs-keyword">float</span> radius, Color color);                         <span class="hljs-comment">// Рисуем контур круга</span>
    <span class="hljs-keyword">void</span> DrawCircleLinesV(Vector2 center, <span class="hljs-keyword">float</span> radius, Color color);                                  <span class="hljs-comment">// Рисуем контур круга (векторная версия)</span>
    <span class="hljs-keyword">void</span> DrawEllipse(<span class="hljs-keyword">int</span> centerX, <span class="hljs-keyword">int</span> centerY, <span class="hljs-keyword">float</span> radiusH, <span class="hljs-keyword">float</span> radiusV, Color color);             <span class="hljs-comment">// Рисуем эллипс</span>
    <span class="hljs-keyword">void</span> DrawEllipseLines(<span class="hljs-keyword">int</span> centerX, <span class="hljs-keyword">int</span> centerY, <span class="hljs-keyword">float</span> radiusH, <span class="hljs-keyword">float</span> radiusV, Color color);        <span class="hljs-comment">// Рисуем контур эллипса</span>
    <span class="hljs-keyword">void</span> DrawRing(Vector2 center, <span class="hljs-keyword">float</span> innerRadius, <span class="hljs-keyword">float</span> outerRadius, <span class="hljs-keyword">float</span> startAngle, <span class="hljs-keyword">float</span> endAngle, <span class="hljs-keyword">int</span> segments, Color color); <span class="hljs-comment">// Нарисовать кольцо</span>
    <span class="hljs-keyword">void</span> DrawRingLines(Vector2 center, <span class="hljs-keyword">float</span> innerRadius, <span class="hljs-keyword">float</span> outerRadius, <span class="hljs-keyword">float</span> startAngle, <span class="hljs-keyword">float</span> endAngle, <span class="hljs-keyword">int</span> segments, Color color);    <span class="hljs-comment">// Рисуем контур кольца</span>
    <span class="hljs-keyword">void</span> DrawRectangle(<span class="hljs-keyword">int</span> posX, <span class="hljs-keyword">int</span> posY, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height, Color color);                        <span class="hljs-comment">// Рисуем прямоугольник, залитый цветом</span>
    <span class="hljs-keyword">void</span> DrawRectangleV(Vector2 position, Vector2 size, Color color);                                  <span class="hljs-comment">// Рисуем прямоугольник, залитый цветом (векторная версия)</span>
    <span class="hljs-keyword">void</span> DrawRectangleRec(Rectangle rec, Color color);                                                 <span class="hljs-comment">// Рисуем прямоугольник, залитый цветом</span>
    <span class="hljs-keyword">void</span> DrawRectanglePro(Rectangle rec, Vector2 origin, <span class="hljs-keyword">float</span> rotation, Color color);                 <span class="hljs-comment">// Рисуем залитый цветом прямоугольник с параметрами pro</span>
    <span class="hljs-keyword">void</span> DrawRectangleGradientV(<span class="hljs-keyword">int</span> posX, <span class="hljs-keyword">int</span> posY, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height, Color color1, Color color2);<span class="hljs-comment">// Рисуем прямоугольник с вертикальным градиентом</span>
    <span class="hljs-keyword">void</span> DrawRectangleGradientH(<span class="hljs-keyword">int</span> posX, <span class="hljs-keyword">int</span> posY, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height, Color color1, Color color2);<span class="hljs-comment">// Рисуем прямоугольник с горизонтальным градиентом</span>
    <span class="hljs-keyword">void</span> DrawRectangleGradientEx(Rectangle rec, Color col1, Color col2, Color col3, Color col4);       <font></font>
<span class="hljs-comment">    // Рисуем прямоугольник с градиентной заливкой и пользовательскими цветами вершин</span>
    <span class="hljs-keyword">void</span> DrawRectangleLines(<span class="hljs-keyword">int</span> posX, <span class="hljs-keyword">int</span> posY, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height, Color color);                   <span class="hljs-comment">// Рисуем контур прямоугольника</span>
    <span class="hljs-keyword">void</span> DrawRectangleLinesEx(Rectangle rec, <span class="hljs-keyword">float</span> lineThick, Color color);                            <span class="hljs-comment">// Рисуем контур прямоугольника с расширенными параметрами</span>
    <span class="hljs-keyword">void</span> DrawRectangleRounded(Rectangle rec, <span class="hljs-keyword">float</span> roundness, <span class="hljs-keyword">int</span> segments, Color color);              <span class="hljs-comment">// Рисуем прямоугольник с закругленными краями</span>
    <span class="hljs-keyword">void</span> DrawRectangleRoundedLines(Rectangle rec, <span class="hljs-keyword">float</span> roundness, <span class="hljs-keyword">int</span> segments, <span class="hljs-keyword">float</span> lineThick, Color color); <span class="hljs-comment">// Рисуем прямоугольник с контуром закругленных краев</span>
    <span class="hljs-keyword">void</span> DrawTriangle(Vector2 v1, Vector2 v2, Vector2 v3, Color color);                                <font></font>
<span class="hljs-comment">    // Рисуем закрашенный треугольник (вершины расположены против часовой стрелки!)</span>
    <span class="hljs-keyword">void</span> DrawTriangleLines(Vector2 v1, Vector2 v2, Vector2 v3, Color color);                           <span class="hljs-comment">// Рисуем контур треугольника (вершины против часовой стрелки!)</span>
    <span class="hljs-keyword">void</span> DrawTriangleFan(Vector2 *points, <span class="hljs-keyword">int</span> pointCount, Color color);                                <span class="hljs-comment">// Рисуем веер треугольника, определяемый точками (первая вершина — центр)</span>
    <span class="hljs-keyword">void</span> DrawTriangleStrip(Vector2 *points, <span class="hljs-keyword">int</span> pointCount, Color color);                              <span class="hljs-comment">// Рисуем полосу треугольника, определяемую точками</span>
    <span class="hljs-keyword">void</span> DrawPoly(Vector2 center, <span class="hljs-keyword">int</span> sides, <span class="hljs-keyword">float</span> radius, <span class="hljs-keyword">float</span> rotation, Color color);               <span class="hljs-comment">// Рисуем правильный многоугольник (Векторная версия)</span>
    <span class="hljs-keyword">void</span> DrawPolyLines(Vector2 center, <span class="hljs-keyword">int</span> sides, <span class="hljs-keyword">float</span> radius, <span class="hljs-keyword">float</span> rotation, Color color);          <span class="hljs-comment">// Рисуем контур многоугольника из n сторон</span>
    <span class="hljs-keyword">void</span> DrawPolyLinesEx(Vector2 center, <span class="hljs-keyword">int</span> sides, <span class="hljs-keyword">float</span> radius, <span class="hljs-keyword">float</span> rotation, <span class="hljs-keyword">float</span> lineThick, Color color); <font></font>
<span class="hljs-comment">    // Рисуем контур многоугольника из n сторон с расширенными параметрами</span><font></font>
<font></font>
    <span class="hljs-comment">// Функции рисования сплайнов</span>
    <span class="hljs-keyword">void</span> DrawSplineLinear(Vector2 *points, <span class="hljs-keyword">int</span> pointCount, <span class="hljs-keyword">float</span> thick, Color color);                  <span class="hljs-comment">// Рисование сплайна: линейный, минимум 2 точки</span>
    <span class="hljs-keyword">void</span> DrawSplineBasis(Vector2 *points, <span class="hljs-keyword">int</span> pointCount, <span class="hljs-keyword">float</span> thick, Color color);                   <span class="hljs-comment">// Рисование сплайна: B-Spline, минимум 4 точки</span>
    <span class="hljs-keyword">void</span> DrawSplineCatmullRom(Vector2 *points, <span class="hljs-keyword">int</span> pointCount, <span class="hljs-keyword">float</span> thick, Color color);              <span class="hljs-comment">// Рисование сплайна: Catmull-Rom, минимум 4 точки</span>
    <span class="hljs-keyword">void</span> DrawSplineBezierQuadratic(Vector2 *points, <span class="hljs-keyword">int</span> pointCount, <span class="hljs-keyword">float</span> thick, Color color);         
 <span class="hljs-comment">// Рисование сплайна: квадратичная кривая Безье, минимум 3 точки (1 контрольная точка): [p1, c2, p3, c4...]</span>
    <span class="hljs-keyword">void</span> DrawSplineBezierCubic(Vector2 *points, <span class="hljs-keyword">int</span> pointCount, <span class="hljs-keyword">float</span> thick, Color color);             <span class="hljs-comment">// Рисование сплайна: Кубическая Безье, минимум 4 точки (2 контрольные точки): [p1, c2, c3, p4, c5, c6...]</span>
    <span class="hljs-keyword">void</span> DrawSplineSegmentLinear(Vector2 p1, Vector2 p2, <span class="hljs-keyword">float</span> thick, Color color);                    <span class="hljs-comment">// Рисуем сегмент сплайна: Линейный, 2 точки</span>
    <span class="hljs-keyword">void</span> DrawSplineSegmentBasis(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, <span class="hljs-keyword">float</span> thick, Color color); <span class="hljs-comment">// Рисуем сегмент сплайна: B-Spline, 4 точки</span>
    <span class="hljs-keyword">void</span> DrawSplineSegmentCatmullRom(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, <span class="hljs-keyword">float</span> thick, Color color); <span class="hljs-comment">// Рисуем сегмент сплайна: Catmull-Rom, 4 точки</span>
    <span class="hljs-keyword">void</span> DrawSplineSegmentBezierQuadratic(Vector2 p1, Vector2 c2, Vector2 p3, <span class="hljs-keyword">float</span> thick, Color color); <span class="hljs-comment">// Рисование сегмента сплайна: квадратичная кривая Безье, 2 точки, 1 контрольная точка</span>
    <span class="hljs-keyword">void</span> DrawSplineSegmentBezierCubic(Vector2 p1, Vector2 c2, Vector2 c3, Vector2 p4, <span class="hljs-keyword">float</span> thick, Color color); <span class="hljs-comment">// Рисуем сегмент сплайна: Кубическая Безье, 2 точки, 2 контрольные точки</span><font></font>
<font></font>
    <span class="hljs-comment">// Функции оценки точки сегмента сплайна для заданного t [0.0f .. 1.0f]</span>
    Vector2 GetSplinePointLinear(Vector2 startPos, Vector2 endPos, <span class="hljs-keyword">float</span> t);                           <span class="hljs-comment">// Получить (оценить) точку сплайна: Линейная</span>
    Vector2 GetSplinePointBasis(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, <span class="hljs-keyword">float</span> t);              <span class="hljs-comment">// Получить (оценить) точку сплайна: B-Spline</span>
    Vector2 GetSplinePointCatmullRom(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, <span class="hljs-keyword">float</span> t);         <span class="hljs-comment">// Получить (оценить) точку сплайна: Catmull-Rom</span>
    Vector2 GetSplinePointBezierQuad(Vector2 p1, Vector2 c2, Vector2 p3, <span class="hljs-keyword">float</span> t);                     <span class="hljs-comment">// Получить (оценить) точку сплайна: Quadratic Bezier</span>
    Vector2 GetSplinePointBezierCubic(Vector2 p1, Vector2 c2, Vector2 c3, Vector2 p4, <span class="hljs-keyword">float</span> t);        <span class="hljs-comment">// Получить (оценить) точку сплайна: Cubic Bezier</span><font></font>
<font></font>
    <span class="hljs-comment">// Основные функции обнаружения пересечения фигур</span>
    <span class="hljs-keyword">bool</span> CheckCollisionRecs(Rectangle rec1, Rectangle rec2);                                           <span class="hljs-comment">// Проверяем пересечение двух прямоугольников</span>
    <span class="hljs-keyword">bool</span> CheckCollisionCircles(Vector2 center1, <span class="hljs-keyword">float</span> radius1, Vector2 center2, <span class="hljs-keyword">float</span> radius2);        <span class="hljs-comment">// Проверяем пересечение двух окружностей</span>
    <span class="hljs-keyword">bool</span> CheckCollisionCircleRec(Vector2 center, <span class="hljs-keyword">float</span> radius, Rectangle rec);                         <span class="hljs-comment">// Проверяем пересечение окружности и прямоугольника</span>
    <span class="hljs-keyword">bool</span> CheckCollisionPointRec(Vector2 point, Rectangle rec);                                         <span class="hljs-comment">// Проверяем, находится ли точка внутри прямоугольника</span>
    <span class="hljs-keyword">bool</span> CheckCollisionPointCircle(Vector2 point, Vector2 center, <span class="hljs-keyword">float</span> radius);                       <span class="hljs-comment">// Проверяем, находится ли точка внутри круга</span>
    <span class="hljs-keyword">bool</span> CheckCollisionPointTriangle(Vector2 point, Vector2 p1, Vector2 p2, Vector2 p3);               <span class="hljs-comment">// Проверяем, находится ли точка внутри треугольника</span>
    <span class="hljs-keyword">bool</span> CheckCollisionPointPoly(Vector2 point, Vector2 *points, <span class="hljs-keyword">int</span> pointCount);                      <span class="hljs-comment">// Проверяем, находится ли точка внутри многоугольника, описанного массивом вершин</span>
    <span class="hljs-keyword">bool</span> CheckCollisionLines(Vector2 startPos1, Vector2 endPos1, Vector2 startPos2, Vector2 endPos2, Vector2 *collisionPoint); <span class="hljs-comment">// Проверяем пересеч. 2-х линий, каждая опре-тся 2-мя точк., возвращ. точку столкн. по ссылке</span>
    <span class="hljs-keyword">bool</span> CheckCollisionPointLine(Vector2 point, Vector2 p1, Vector2 p2, <span class="hljs-keyword">int</span> threshold);                <span class="hljs-comment">// Проверяем, принадлежит ли точка линии, созданной между точками [p1] и [p2] с заданн. запасом в пикс. [порог]</span>
    Rectangle GetCollisionRec(Rectangle rec1, Rectangle rec2);                                         <span class="hljs-comment">// Получаем прямоугольник пересечения для двух прямоугольников</span><font></font>
<font></font>
</code></pre></div>
            <p id="ptextures"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">модуль: rtextures</font></font></p>
            <div id="textures"><pre><code class="cpp hljs ">    <span class="hljs-comment">// Функции загрузки изображения</span>
    <span class="hljs-comment">// ПРИМЕЧАНИЕ. Эти функции не требуют доступа к графическому процессору.</span>
    Image LoadImage(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fileName);                                                             <span class="hljs-comment">// Загружаем изображение из файла в память процессора (ОЗУ)</span>
    Image LoadImageRaw(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fileName, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height, <span class="hljs-keyword">int</span> format, <span class="hljs-keyword">int</span> headerSize);       <span class="hljs-comment">// Загрузка изображения из данных файла RAW</span>
    Image LoadImageSvg(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fileNameOrString, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height);                           <span class="hljs-comment">// Загрузка изображения из данных файла SVG или строки указанного размера</span>
    Image LoadImageAnim(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fileName, <span class="hljs-keyword">int</span> *frames);                                            <span class="hljs-comment">// Загрузка последовательности изображений из файла (кадры добавлены в image.data)</span>
    Image LoadImageFromMemory(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fileType, <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *fileData, <span class="hljs-keyword">int</span> dataSize);      <span class="hljs-comment">// Загрузка изображения из буфера памяти, тип файла относится к расширению: т.е. '.png'</span>
    Image LoadImageFromTexture(Texture2D texture);                                                     <span class="hljs-comment">// Загружаем изображение из данных текстуры графического процессора</span>
    Image LoadImageFromScreen(<span class="hljs-keyword">void</span>);                                                                   <span class="hljs-comment">// Загружаем изображение из буфера экрана и (скриншот)</span>
    <span class="hljs-keyword">bool</span> IsImageReady(Image image);                                                                    <span class="hljs-comment">// Проверяем, готово ли изображение</span>
    <span class="hljs-keyword">void</span> UnloadImage(Image image);                                                                     <span class="hljs-comment">// Выгружаем изображение из памяти процессора (RAM)</span>
    <span class="hljs-keyword">bool</span> ExportImage(Image image, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fileName);                                               <span class="hljs-comment">// Экспорт данных изображения в файл, в случае успеха возвращает true</span>
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *ExportImageToMemory(Image image, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fileType, <span class="hljs-keyword">int</span> *fileSize);              <span class="hljs-comment">// Экспортируем изображение в буфер памяти</span>
    <span class="hljs-keyword">bool</span> ExportImageAsCode(Image image, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fileName);                                         <span class="hljs-comment">// Экспортируем изображение как файл кода, определяющий массив байтов, в случае успеха возвращает true</span><font></font>
<font></font>
    <span class="hljs-comment">// Функции генерации изображения</span>
    Image GenImageColor(<span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height, Color color);                                           <span class="hljs-comment">// Генерируем изображение: простой цвет</span>
    Image GenImageGradientLinear(<span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height, <span class="hljs-keyword">int</span> direction, Color start, Color end);        <span class="hljs-comment">// Генерируем изображение: линейный градиент, направление в градусах [0..360], 0=Вертикальный градиент</span>
    Image GenImageGradientRadial(<span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height, <span class="hljs-keyword">float</span> density, Color inner, Color outer);      <span class="hljs-comment">// Генерируем изображение: радиальный градиент</span>
    Image GenImageGradientSquare(<span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height, <span class="hljs-keyword">float</span> density, Color inner, Color outer);      <span class="hljs-comment">// Генерируем изображение: квадратный градиент</span>
    Image GenImageChecked(<span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height, <span class="hljs-keyword">int</span> checksX, <span class="hljs-keyword">int</span> checksY, Color col1, Color col2);    <span class="hljs-comment">// Генерировать изображение: checked</span>
    Image GenImageWhiteNoise(<span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height, <span class="hljs-keyword">float</span> factor);                                     <span class="hljs-comment">// Генерировать изображение: белый шум</span>
    Image GenImagePerlinNoise(<span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height, <span class="hljs-keyword">int</span> offsetX, <span class="hljs-keyword">int</span> offsetY, <span class="hljs-keyword">float</span> scale);           <span class="hljs-comment">// Генерируем изображение: шум Перлина</span>
    Image GenImageCellular(<span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height, <span class="hljs-keyword">int</span> tileSize);                                       <span class="hljs-comment">// Генерация изображения: клеточный алгоритм, больший размер плитки означает больший размер ячеек</span>
    Image GenImageText(<span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *text);                                       <span class="hljs-comment">// Генерация изображения: изображение в оттенках серого из текстовых данных</span><font></font>
<font></font>
    <span class="hljs-comment">// Функции манипулирования изображениями</span>
    Image ImageCopy(Image image);                                                                      <span class="hljs-comment">// Создаем дубликат изображения (полезно для преобразований)</span>
    Image ImageFromImage(Image image, Rectangle rec);                                                  <span class="hljs-comment">// Создаем изображение из другого фрагмента изображения</span>
    Image ImageText(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *text, <span class="hljs-keyword">int</span> fontSize, Color color);                                      <span class="hljs-comment">// Создаем изображение из текста (шрифт по умолчанию)</span>
    Image ImageTextEx(Font font, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *text, <span class="hljs-keyword">float</span> fontSize, <span class="hljs-keyword">float</span> spacing, Color tint);         <span class="hljs-comment">// Создаем изображение из текста (пользовательский шрифт спрайта)</span>
    <span class="hljs-keyword">void</span> ImageFormat(Image *image, <span class="hljs-keyword">int</span> newFormat);                                                     <span class="hljs-comment">// Конвертируем данные изображения в нужный формат</span>
    <span class="hljs-keyword">void</span> ImageToPOT(Image *image, Color fill);                                                         <span class="hljs-comment">// Конвертируем изображение в POT (степень двойки)</span>
    <span class="hljs-keyword">void</span> ImageCrop(Image *image, Rectangle crop);                                                      <span class="hljs-comment">// Обрезаем изображение до определенного прямоугольника</span>
    <span class="hljs-keyword">void</span> ImageAlphaCrop(Image *image, <span class="hljs-keyword">float</span> threshold);                                                <span class="hljs-comment">// Обрезаем изображение в зависимости от значения альфа</span>
    <span class="hljs-keyword">void</span> ImageAlphaClear(Image *image, Color color, <span class="hljs-keyword">float</span> threshold);                                  <span class="hljs-comment">// Очистка альфа-канала до желаемого цвета</span>
    <span class="hljs-keyword">void</span> ImageAlphaMask(Image *image, Image alphaMask);                                                <span class="hljs-comment">// Применяем альфа-маску к изображению</span>
    <span class="hljs-keyword">void</span> ImageAlphaPremultiply(Image *image);                                                          <span class="hljs-comment">// Предварительное умножение альфа-канала</span>
    <span class="hljs-keyword">void</span> ImageBlurGaussian(Image *image, <span class="hljs-keyword">int</span> blurSize);                                                <span class="hljs-comment">// Применяем размытие по Гауссу, используя приближение размытия прямоугольника</span>
    <span class="hljs-keyword">void</span> ImageResize(Image *image, <span class="hljs-keyword">int</span> newWidth, <span class="hljs-keyword">int</span> newHeight);                                       <span class="hljs-comment">// Изменение размера изображения (алгоритм бикубического масштабирования)</span>
    <span class="hljs-keyword">void</span> ImageResizeNN(Image *image, <span class="hljs-keyword">int</span> newWidth,<span class="hljs-keyword">int</span> newHeight);                                      <span class="hljs-comment">// Изменение размера изображения (алгоритм масштабирования по ближайшему соседу)</span>
    <span class="hljs-keyword">void</span> ImageResizeCanvas(Image *image, <span class="hljs-keyword">int</span> newWidth, <span class="hljs-keyword">int</span> newHeight, <span class="hljs-keyword">int</span> offsetX, <span class="hljs-keyword">int</span> offsetY, Color fill);  <span class="hljs-comment">// Изменяем размер холста и заливаем цветом</span>
    <span class="hljs-keyword">void</span> ImageMipmaps(Image *image);                                                                   <span class="hljs-comment">// Вычисляем все уровни MIP-карт для предоставленного изображения</span>
    <span class="hljs-keyword">void</span> ImageDither(Image *image, <span class="hljs-keyword">int</span> rBpp, <span class="hljs-keyword">int</span> gBpp, <span class="hljs-keyword">int</span> bBpp, <span class="hljs-keyword">int</span> aBpp);                            <span class="hljs-comment">// Сглаживание данных изображения до 16 бит на пиксель или ниже (сглаживание Флойда-Стейнберга)</span>
    <span class="hljs-keyword">void</span> ImageFlipVertical(Image *image);                                                              <span class="hljs-comment">// Переворачиваем изображение по вертикали</span>
    <span class="hljs-keyword">void</span> ImageFlipHorizontal(Image *image);                                                            <span class="hljs-comment">// Переворачиваем изображение по горизонтали</span>
    <span class="hljs-keyword">void</span> ImageRotate(Image *image, <span class="hljs-keyword">int</span> degrees);                                                       <span class="hljs-comment">// Поворот изображения на введенный угол в градусах (от -359 до 359)</span>
    <span class="hljs-keyword">void</span> ImageRotateCW(Image *image);                                                                  <span class="hljs-comment">// Поворот изображения по часовой стрелке на 90 градусов</span>
    <span class="hljs-keyword">void</span> ImageRotateCCW(Image *image);                                                                 <span class="hljs-comment">// Поворот изображения против часовой стрелки на 90 градусов</span>
    <span class="hljs-keyword">void</span> ImageColorTint(Image *image, Color color);                                                    <span class="hljs-comment">// Изменяем цвет изображения: оттенок</span>
    <span class="hljs-keyword">void</span> ImageColorInvert(Image *image);                                                               <span class="hljs-comment">// Изменяем цвет изображения: инвертируем</span>
    <span class="hljs-keyword">void</span> ImageColorGrayscale(Image *image);                                                            <span class="hljs-comment">// Изменяем цвет изображения: оттенки серого</span>
    <span class="hljs-keyword">void</span> ImageColorContrast(Image *image, <span class="hljs-keyword">float</span> contrast);                                             <span class="hljs-comment">// Изменить цвет изображения: контраст (от -100 до 100)</span>
    <span class="hljs-keyword">void</span> ImageColorBrightness(Image *image, <span class="hljs-keyword">int</span> brightness);                                           <span class="hljs-comment">// Изменяем цвет изображения: яркость (от -255 до 255)</span>
    <span class="hljs-keyword">void</span> ImageColorReplace(Image *image, Color color, Color replace);                                  <span class="hljs-comment">// Изменить цвет изображения: заменить цвет</span>
    Color *LoadImageColors(Image image);                                                               <span class="hljs-comment">// Загрузка данных цвета из изображения в виде массива цветов (RGBA – 32 бита)</span>
    Color *LoadImagePalette(Image image, <span class="hljs-keyword">int</span> maxPaletteSize, <span class="hljs-keyword">int</span> *colorCount);                         <span class="hljs-comment">// Загружаем палитру цветов из изображения в виде массива цветов (RGBA – 32 бита)</span>
    <span class="hljs-keyword">void</span> UnloadImageColors(Color *colors);                                                             <span class="hljs-comment">// Выгружаем данные цвета, загруженные с помощью LoadImageColors()</span>
    <span class="hljs-keyword">void</span> UnloadImagePalette(Color *colors);                                                            <span class="hljs-comment">// Выгружаем палитру цветов, загруженную с помощью LoadImagePalette()</span>
    Rectangle GetImageAlphaBorder(Image image, <span class="hljs-keyword">float</span> threshold);                                       <span class="hljs-comment">// Получаем прямоугольник альфа-границы изображения</span>
    Color GetImageColor(Image image, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y);                                                    <span class="hljs-comment">// Получаем цвет пикселя изображения в позиции (x, y)</span><font></font>
<font></font>
    <span class="hljs-comment">// Функции рисования изображений</span>
    <span class="hljs-comment">// ПРИМЕЧАНИЕ. Функции программного рендеринга изображений (ЦП)</span>
    <span class="hljs-keyword">void</span> ImageClearBackground(Image *dst, Color color);                                                <span class="hljs-comment">// Очистить фон изображения заданным цветом</span>
    <span class="hljs-keyword">void</span> ImageDrawPixel(Image *dst, <span class="hljs-keyword">int</span> posX, <span class="hljs-keyword">int</span> posY, Color color);                                  <span class="hljs-comment">// Рисуем пиксель внутри изображения</span>
    <span class="hljs-keyword">void</span> ImageDrawPixelV(Image *dst, Vector2 position, Color color);                                   <span class="hljs-comment">// Рисуем пиксель внутри изображения (векторная версия)</span>
    <span class="hljs-keyword">void</span> ImageDrawLine(Image *dst, <span class="hljs-keyword">int</span> startPosX, <span class="hljs-keyword">int</span> startPosY, <span class="hljs-keyword">int</span> endPosX, <span class="hljs-keyword">int</span> endPosY, Color color); <span class="hljs-comment">// Рисуем линию внутри изображения</span>
    <span class="hljs-keyword">void</span> ImageDrawLineV(Image *dst, Vector2 start, Vector2 end, Color color);                          <span class="hljs-comment">// Рисуем линию внутри изображения (векторная версия)</span>
    <span class="hljs-keyword">void</span> ImageDrawCircle(Image *dst, <span class="hljs-keyword">int</span> centerX, <span class="hljs-keyword">int</span> centerY, <span class="hljs-keyword">int</span> radius, Color color);               <span class="hljs-comment">// Рисуем закрашенный круг внутри изображения</span>
    <span class="hljs-keyword">void</span> ImageDrawCircleV(Image *dst, Vector2 center, <span class="hljs-keyword">int</span> radius, Color color);                        <span class="hljs-comment">// Рисуем закрашенный круг внутри изображения (векторная версия)</span>
    <span class="hljs-keyword">void</span> ImageDrawCircleLines(Image *dst, <span class="hljs-keyword">int</span> centerX, <span class="hljs-keyword">int</span> centerY, <span class="hljs-keyword">int</span> radius, Color color);          <span class="hljs-comment">// Рисуем контур круга внутри изображения</span>
    <span class="hljs-keyword">void</span> ImageDrawCircleLinesV(Image *dst, Vector2 center, <span class="hljs-keyword">int</span> radius, Color color);                   <span class="hljs-comment">// Рисуем контур круга внутри изображения (векторная версия)</span>
    <span class="hljs-keyword">void</span> ImageDrawRectangle(Image *dst, <span class="hljs-keyword">int</span> posX, <span class="hljs-keyword">int</span> posY, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height, Color color);       <span class="hljs-comment">// Рисуем прямоугольник внутри изображения</span>
    <span class="hljs-keyword">void</span> ImageDrawRectangleV(Image *dst, Vector2 position, Vector2 size, Color color);                 <span class="hljs-comment">// Рисуем прямоугольник внутри изображения (векторная версия)</span>
    <span class="hljs-keyword">void</span> ImageDrawRectangleRec(Image *dst, Rectangle rec, Color color);                                <span class="hljs-comment">// Рисуем прямоугольник внутри изображения</span>
    <span class="hljs-keyword">void</span> ImageDrawRectangleLines(Image *dst, Rectangle rec, <span class="hljs-keyword">int</span> thick, Color color);                   <span class="hljs-comment">// Рисуем прямоугольные линии внутри изображения</span>
    <span class="hljs-keyword">void</span> ImageDraw(Image *dst, Image src, Rectangle srcRec, Rectangle dstRec, Color tint);             <span class="hljs-comment">// Рисуем исходное изображение внутри целевого изображения (оттенок применяется к источнику)</span>
    <span class="hljs-keyword">void</span> ImageDrawText(Image *dst, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *text, <span class="hljs-keyword">int</span> posX, <span class="hljs-keyword">int</span> posY, <span class="hljs-keyword">int</span> fontSize, Color color);   <span class="hljs-comment">// Рисуем текст (используя шрифт по умолчанию) внутри изображения (место назначения)</span>
    <span class="hljs-keyword">void</span> ImageDrawTextEx(Image *dst, Font font, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *text, Vector2 position, <span class="hljs-keyword">float</span> fontSize, <span class="hljs-keyword">float</span> spacing, Color tint); <span class="hljs-comment">// Рисуем текст (пользовательский шрифт спрайта) внутри изображения (место назначения)</span><font></font>
<font></font>
    <span class="hljs-comment">// Функции загрузки текстур</span>
    <span class="hljs-comment">// ПРИМЕЧАНИЕ. Эти функции требуют доступа к графическому процессору.</span>
    Texture2D LoadTexture(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fileName);                                                       <span class="hljs-comment">// Загружаем текстуру из файла в память графического процессора (VRAM)</span>
    Texture2D LoadTextureFromImage(Image image);                                                       <span class="hljs-comment">// Загружаем текстуру из данных изображения</span>
    TextureCubemap LoadTextureCubemap(Image image, <span class="hljs-keyword">int</span> layout);                                        <span class="hljs-comment">// Загрузка кубической карты из изображения, поддерживается несколько макетов кубической карты изображения</span>
    RenderTexture2D LoadRenderTexture(<span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height);                                          <span class="hljs-comment">// Загружаем текстуру для рендеринга (фреймбуфер)</span>
    <span class="hljs-keyword">bool</span> IsTextureReady(Texture2D texture);                                                            <span class="hljs-comment">// Проверяем, готова ли текстура</span>
    <span class="hljs-keyword">void</span> UnloadTexture(Texture2D texture);                                                             <span class="hljs-comment">// Выгружаем текстуру из памяти графического процессора (VRAM)</span>
    <span class="hljs-keyword">bool</span> IsRenderTextureReady(RenderTexture2D target);                                                 <span class="hljs-comment">// Проверяем, готова ли текстура рендеринга</span>
    <span class="hljs-keyword">void</span> UnloadRenderTexture(RenderTexture2D target);                                                  <span class="hljs-comment">// Выгружаем текстуру рендеринга из памяти графического процессора (VRAM)</span>
    <span class="hljs-keyword">void</span> UpdateTexture(Texture2D texture, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *pixels);                                         <span class="hljs-comment">// Обновляем текстуру графического процессора новыми данными</span>
    <span class="hljs-keyword">void</span> UpdateTextureRec(Texture2D texture, Rectangle rec, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *pixels);                       <span class="hljs-comment">// Обновляем прямоугольник текстуры графического процессора новыми данными</span><font></font>
<font></font>
    <span class="hljs-comment">// Функции настройки текстуры</span>
    <span class="hljs-keyword">void</span> GenTextureMipmaps(Texture2D *texture);                                                        <span class="hljs-comment">// Генерируем MIP-карты графического процессора для текстуры</span>
    <span class="hljs-keyword">void</span> SetTextureFilter(Texture2D texture, <span class="hljs-keyword">int</span> filter);                                              <span class="hljs-comment">// Устанавливаем режим фильтра масштабирования текстур</span>
    <span class="hljs-keyword">void</span> SetTextureWrap(Texture2D texture, <span class="hljs-keyword">int</span> wrap);                                                  <span class="hljs-comment">// Устанавливаем режим обтекания текстурой</span><font></font>
<font></font>
    <span class="hljs-comment">// Функции рисования текстур</span>
    <span class="hljs-keyword">void</span> DrawTexture(Texture2D texture, <span class="hljs-keyword">int</span> posX, <span class="hljs-keyword">int</span> posY, Color tint);                               <span class="hljs-comment">// Рисуем текстуру2D</span>
    <span class="hljs-keyword">void</span> DrawTextureV(Texture2D texture, Vector2 position, Color tint);                                <span class="hljs-comment">// Рисуем текстуру2D с позицией, определенной как Vector2</span>
    <span class="hljs-keyword">void</span> DrawTextureEx(Texture2D texture, Vector2 position, <span class="hljs-keyword">float</span> rotation, <span class="hljs-keyword">float</span> scale, Color tint);  <span class="hljs-comment">// Рисуем текстуру2D с расширенными параметрами</span>
    <span class="hljs-keyword">void</span> DrawTextureRec(Texture2D texture, Rectangle source, Vector2 position, Color tint);            <span class="hljs-comment">// Рисуем часть текстуры, определенную прямоугольником</span>
    <span class="hljs-keyword">void</span> DrawTexturePro(Texture2D texture, Rectangle source, Rectangle dest, Vector2 origin, <span class="hljs-keyword">float</span> rotation, Color tint); <span class="hljs-comment">// Рисуем часть текстуры, определенную прямоугольником, с параметрами pro</span>
    <span class="hljs-keyword">void</span> DrawTextureNPatch(Texture2D texture, NPatchInfo nPatchInfo, Rectangle dest, Vector2 origin, <span class="hljs-keyword">float</span> rotation, Color tint); <span class="hljs-comment">// Рисует текстуру (или ее часть), которая красиво растягивается или сжимается</span><font></font>
<font></font>
    <span class="hljs-comment">// Функции, связанные с цветом/пикселем</span>
    Color Fade(Color color, <span class="hljs-keyword">float</span> alpha);                                 <span class="hljs-comment">// Получаем цвет с применением альфа, альфа меняется от 0.0f до 1.0f</span>
    <span class="hljs-keyword">int</span> ColorToInt(Color color);                                          <span class="hljs-comment">// Получаем шестнадцатеричное значение цвета</span>
    Vector4 ColorNormalize(Color color);                                  <span class="hljs-comment">// Получаем цвет, нормализованный как число с плавающей запятой [0..1]</span>
    Color ColorFromNormalized(Vector4 normalized);                        <span class="hljs-comment">// Получаем цвет из нормализованных значений [0..1]</span>
    Vector3 ColorToHSV(Color color);                                      <span class="hljs-comment">// Получаем значения HSV для цвета, оттенка [0..360], насыщенности/значения [0..1]</span>
    Color ColorFromHSV(<span class="hljs-keyword">float</span> hue, <span class="hljs-keyword">float</span> saturation, <span class="hljs-keyword">float</span> value);         <span class="hljs-comment">// Получаем цвет из значений HSV, оттенка [0..360], насыщенности/значения [0..1]</span>
    Color ColorTint(Color color, Color tint);                             <span class="hljs-comment">// Получаем цвет, умноженный на другой цвет</span>
    Color ColorBrightness(Color color, <span class="hljs-keyword">float</span> factor);                     <span class="hljs-comment">// Get color with brightness correction, brightness factor goes from -1.0f to 1.0f</span>
    Color ColorContrast(Color color, <span class="hljs-keyword">float</span> contrast);                     <span class="hljs-comment">// Получаем цвет с коррекцией контраста, значения контрастности от -1.0f до 1.0f</span>
    Color ColorAlpha(Color color, <span class="hljs-keyword">float</span> alpha);                           <span class="hljs-comment">// Получаем цвет с применением альфа, альфа меняется от 0.0f до 1.0f</span>
    Color ColorAlphaBlend(Color dst, Color src, Color tint);              <span class="hljs-comment">// Получаем альфа-смешение src с цветом dst с оттенком</span>
    Color GetColor(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> hexValue);                                <span class="hljs-comment">// Получаем структуру цвета из шестнадцатеричного значения</span>
    Color GetPixelColor(<span class="hljs-keyword">void</span> *srcPtr, <span class="hljs-keyword">int</span> format);                        <span class="hljs-comment">// Получаем цвет из указателя исходного пикселя определенного формата</span>
    <span class="hljs-keyword">void</span> SetPixelColor(<span class="hljs-keyword">void</span> *dstPtr, Color color, <span class="hljs-keyword">int</span> format);            <span class="hljs-comment">// Устанавливаем цвет, отформатированный в указатель целевого пикселя</span>
    <span class="hljs-keyword">int</span> GetPixelDataSize(<span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height, <span class="hljs-keyword">int</span> format);              <span class="hljs-comment">// Получаем размер данных пикселей в байтах для определенного формата</span><font></font>
<font></font>
</code></pre></div>
            <p id="ptext"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">модуль: rtext</font></font></p>
            <div id="text"><pre><code class="cpp hljs ">    <span class="hljs-comment">// Функции загрузки/выгрузки шрифта</span>
    Font GetFontDefault(<span class="hljs-keyword">void</span>);                                                            <span class="hljs-comment">// Получаем шрифт по умолчанию</span>
    Font LoadFont(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fileName);                                                  <span class="hljs-comment">// Загружаем шрифт из файла в память графического процессора (VRAM)</span>
    Font LoadFontEx(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fileName, <span class="hljs-keyword">int</span> fontSize, <span class="hljs-keyword">int</span> *codepoints, <span class="hljs-keyword">int</span> codepointCount);  <span class="hljs-comment">// Загр. шрифт из файла с расшир. парам., NULL для код. точек и 0 для codepointCount, для загр. набора симв. по умолч.</span>
    Font LoadFontFromImage(Image image, Color key, <span class="hljs-keyword">int</span> firstChar);                        <span class="hljs-comment">// Загружаем шрифт из изображения (стиль XNA)</span>
    Font LoadFontFromMemory(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fileType, <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *fileData, <span class="hljs-keyword">int</span> dataSize, <span class="hljs-keyword">int</span> fontSize, <span class="hljs-keyword">int</span> *codepoints, <span class="hljs-keyword">int</span> codepointCount); <span class="hljs-comment">// Загруз. шрифта из буф. памяти, тип файла относится к расш-ю: т.е. '.ttf'</span>
    <span class="hljs-keyword">bool</span> IsFontReady(Font font);                                                          <span class="hljs-comment">// Проверяем, готов ли шрифт</span>
    GlyphInfo *LoadFontData(<span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *fileData, <span class="hljs-keyword">int</span> dataSize, <span class="hljs-keyword">int</span> fontSize, <span class="hljs-keyword">int</span> *codepoints, <span class="hljs-keyword">int</span> codepointCount, <span class="hljs-keyword">int</span> type); <span class="hljs-comment">// Загружаем данные шрифта для дальнейшего использования</span>
    Image GenImageFontAtlas(<span class="hljs-keyword">const</span> GlyphInfo *glyphs, Rectangle **glyphRecs, <span class="hljs-keyword">int</span> glyphCount, <span class="hljs-keyword">int</span> fontSize, <span class="hljs-keyword">int</span> padding, <span class="hljs-keyword">int</span> packMethod); <span class="hljs-comment">// Генерируем атлас шрифтов изображений, используя информацию о символах</span>
    <span class="hljs-keyword">void</span> UnloadFontData(GlyphInfo *glyphs, <span class="hljs-keyword">int</span> glyphCount);                               <span class="hljs-comment">// Выгружаем информационные данные о символах шрифта (ОЗУ)</span>
    <span class="hljs-keyword">void</span> UnloadFont(Font font);                                                           <span class="hljs-comment">// Выгружаем шрифт из памяти графического процессора (VRAM)</span>
    <span class="hljs-keyword">bool</span> ExportFontAsCode(Font font, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fileName);                               <span class="hljs-comment">// Экспортируем шрифт как файл кода, в случае успеха возвращает true</span><font></font>
<font></font>
    <span class="hljs-comment">// Функции рисования текста</span>
    <span class="hljs-keyword">void</span> DrawFPS(<span class="hljs-keyword">int</span> posX, <span class="hljs-keyword">int</span> posY);                                                     <span class="hljs-comment">// Отрисовываем текущий FPS</span>
    <span class="hljs-keyword">void</span> DrawText(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *text, <span class="hljs-keyword">int</span> posX, <span class="hljs-keyword">int</span> posY, <span class="hljs-keyword">int</span> fontSize, Color color);       <span class="hljs-comment">// Рисуем текст (используя шрифт по умолчанию)</span>
    <span class="hljs-keyword">void</span> DrawTextEx(Font font, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *text, Vector2 position, <span class="hljs-keyword">float</span> fontSize, <span class="hljs-keyword">float</span> spacing, Color tint); <span class="hljs-comment">// Рисуем текст, используя шрифт и дополнительные параметры</span>
    <span class="hljs-keyword">void</span> DrawTextPro(Font font, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *text, Vector2 position, Vector2 origin, <span class="hljs-keyword">float</span> rotation, <span class="hljs-keyword">float</span> fontSize, <span class="hljs-keyword">float</span> spacing, Color tint); <span class="hljs-comment">// Рисуем текст, используя параметры Font и pro (вращение)</span>
    <span class="hljs-keyword">void</span> DrawTextCodepoint(Font font, <span class="hljs-keyword">int</span> codepoint, Vector2 position, <span class="hljs-keyword">float</span> fontSize, Color tint); <span class="hljs-comment">// Рисуем один символ (кодовую точку)</span>
    <span class="hljs-keyword">void</span> DrawTextCodepoints(Font font, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *codepoints, <span class="hljs-keyword">int</span> codepointCount, Vector2 position, <span class="hljs-keyword">float</span> fontSize, <span class="hljs-keyword">float</span> spacing, Color tint); <span class="hljs-comment">// Рисуем несколько символов (кодовую точку)</span><font></font>
<font></font>
    <span class="hljs-comment">// Функции информации о текстовом шрифте</span>
    <span class="hljs-keyword">void</span> SetTextLineSpacing(<span class="hljs-keyword">int</span> spacing);                                                 <span class="hljs-comment">// Установка вертикального межстрочного интервала при рисовании с разрывами строк</span>
    <span class="hljs-keyword">int</span> MeasureText(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *text, <span class="hljs-keyword">int</span> fontSize);                                      <span class="hljs-comment">// Измеряем ширину строки для шрифта по умолчанию</span>
    Vector2 MeasureTextEx(Font font, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *text, <span class="hljs-keyword">float</span> fontSize, <span class="hljs-keyword">float</span> spacing);    <span class="hljs-comment">// Измеряем размер строки для шрифта</span>
    <span class="hljs-keyword">int</span> GetGlyphIndex(Font font, <span class="hljs-keyword">int</span> codepoint);                                          <span class="hljs-comment">// Получить позицию индекса глифа в шрифте для кодовой точки (символа Юникода), вернуться к '?' если не найден</span>
    GlyphInfo GetGlyphInfo(Font font, <span class="hljs-keyword">int</span> codepoint);                                     <span class="hljs-comment">// Получаем информацию о шрифте глифа для кодовой точки (символа Юникода), откат к '?' если не найден</span>
    Rectangle GetGlyphAtlasRec(Font font, <span class="hljs-keyword">int</span> codepoint);                                 <span class="hljs-comment">// Получение прямоугольника глифа в атласе шрифтов для кодовой точки (символа Юникода), возврат к '?' если не найден</span><font></font>
<font></font>
    <span class="hljs-comment">// Функции управления текстовыми кодами (символы Юникода)</span>
    <span class="hljs-keyword">char</span> *LoadUTF8(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *codepoints, <span class="hljs-keyword">int</span> length);                <span class="hljs-comment">// Загружаем текст UTF-8, закодированный из массива кодовых точек</span>
    <span class="hljs-keyword">void</span> UnloadUTF8(<span class="hljs-keyword">char</span> *text);                                      <span class="hljs-comment">// Выгружаем текст UTF-8, закодированный из массива кодовых точек</span>
    <span class="hljs-keyword">int</span> *LoadCodepoints(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *text, <span class="hljs-keyword">int</span> *count);                <span class="hljs-comment">// Загружаем все кодовые точки из текстовой строки UTF-8, количество кодовых точек возвращается параметром</span>
    <span class="hljs-keyword">void</span> UnloadCodepoints(<span class="hljs-keyword">int</span> *codepoints);                           <span class="hljs-comment">// Выгружаем данные кодовых точек из памяти</span>
    <span class="hljs-keyword">int</span> GetCodepointCount(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *text);                          <span class="hljs-comment">// Получаем общее количество кодовых точек в строке в кодировке UTF-8</span>
    <span class="hljs-keyword">int</span> GetCodepoint(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *text, <span class="hljs-keyword">int</span> *codepointSize);           <span class="hljs-comment">// Получаем следующую кодовую точку в строке в кодировке UTF-8, в случае ошибки возвращается 0x3f('?')</span>
    <span class="hljs-keyword">int</span> GetCodepointNext(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *text, <span class="hljs-keyword">int</span> *codepointSize);       <span class="hljs-comment">// Получаем следующую кодовую точку в строке в кодировке UTF-8, в случае ошибки возвращается 0x3f('?')</span>
    <span class="hljs-keyword">int</span> GetCodepointPrevious(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *text, <span class="hljs-keyword">int</span> *codepointSize);   <span class="hljs-comment">// Получаем предыдущий код в строке в кодировке UTF-8, в случае ошибки возвращается 0x3f('?')</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *CodepointToUTF8(<span class="hljs-keyword">int</span> codepoint, <span class="hljs-keyword">int</span> *utf8Size);        <span class="hljs-comment">// Кодируем одну кодовую точку в массив байтов UTF-8 (длина массива возвращается как параметр)</span><font></font>
<font></font>
    <span class="hljs-comment">// Функции управления текстовыми строками (без строк UTF-8, только байтовые символы)</span>
    <span class="hljs-comment">// ПРИМЕЧАНИЕ. Некоторые строки выделяют внутреннюю память для возвращаемых строк, будьте осторожны!</span>
    <span class="hljs-keyword">int</span> TextCopy(<span class="hljs-keyword">char</span> *dst, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *src);                                             <span class="hljs-comment">// Копируем одну строку в другую, возвращает скопированные байты</span>
    <span class="hljs-keyword">bool</span> TextIsEqual(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *text1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *text2);                               <span class="hljs-comment">// Проверяем, равны ли две текстовые строки</span>
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> TextLength(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *text);                                            <span class="hljs-comment">// Получаем длину текста, проверяем окончание '\0'</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *TextFormat(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *text, ...);                                        <span class="hljs-comment">// Форматирование текста с помощью переменных (стиль sprintf())</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *TextSubtext(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *text, <span class="hljs-keyword">int</span> position, <span class="hljs-keyword">int</span> length);                  <span class="hljs-comment">// Получаем фрагмент текстовой строки</span>
    <span class="hljs-keyword">char</span> *TextReplace(<span class="hljs-keyword">char</span> *text, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *replace, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *by);                   <span class="hljs-comment">// Заменяем текстовую строку (ВНИМАНИЕ: память должна быть освобождена!)</span>
    <span class="hljs-keyword">char</span> *TextInsert(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *text, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *insert, <span class="hljs-keyword">int</span> position);                 <span class="hljs-comment">// Вставляем текст в позицию (ВНИМАНИЕ: память должна быть освобождена!)</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *TextJoin(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **textList, <span class="hljs-keyword">int</span> count, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *delimiter);        <span class="hljs-comment">// Объединяем текстовые строки с помощью разделителя</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **TextSplit(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *text, <span class="hljs-keyword">char</span> delimiter, <span class="hljs-keyword">int</span> *count);                 <span class="hljs-comment">// Разбиваем текст на несколько строк</span>
    <span class="hljs-keyword">void</span> TextAppend(<span class="hljs-keyword">char</span> *text, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *append, <span class="hljs-keyword">int</span> *position);                       <span class="hljs-comment">// Добавляем текст в определенную позицию и перемещаем курсор!</span>
    <span class="hljs-keyword">int</span> TextFindIndex(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *text, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *find);                                <span class="hljs-comment">// Находим первое вхождение текста в строке</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *TextToUpper(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *text);                      <span class="hljs-comment">// Получаем версию предоставленной строки в верхнем регистре</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *TextToLower(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *text);                      <span class="hljs-comment">// Получаем версию предоставленной строки в нижнем регистре</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *TextToPascal(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *text);                     <span class="hljs-comment">// Получить версию регистра Pascal предоставленной строки</span>
    <span class="hljs-keyword">int</span> TextToInteger(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *text);                            <span class="hljs-comment">// Получаем целочисленное значение из текста (отрицательные значения не поддерживаются)</span><font></font>
<font></font>
</code></pre></div>
            <p id="pmodels"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">модуль: rmodels</font></font></p>
            <div id="models"><pre><code class="cpp hljs ">    <span class="hljs-comment">// Basic geometric 3D shapes drawing functions</span>
    <span class="hljs-keyword">void</span> DrawLine3D(Vector3 startPos, Vector3 endPos, Color color);                                    <span class="hljs-comment">// Draw a line in 3D world space</span>
    <span class="hljs-keyword">void</span> DrawPoint3D(Vector3 position, Color color);                                                   <span class="hljs-comment">// Draw a point in 3D space, actually a small line</span>
    <span class="hljs-keyword">void</span> DrawCircle3D(Vector3 center, <span class="hljs-keyword">float</span> radius, Vector3 rotationAxis, <span class="hljs-keyword">float</span> rotationAngle, Color color); <span class="hljs-comment">// Draw a circle in 3D world space</span>
    <span class="hljs-keyword">void</span> DrawTriangle3D(Vector3 v1, Vector3 v2, Vector3 v3, Color color);                              <span class="hljs-comment">// Draw a color-filled triangle (vertex in counter-clockwise order!)</span>
    <span class="hljs-keyword">void</span> DrawTriangleStrip3D(Vector3 *points, <span class="hljs-keyword">int</span> pointCount, Color color);                            <span class="hljs-comment">// Draw a triangle strip defined by points</span>
    <span class="hljs-keyword">void</span> DrawCube(Vector3 position, <span class="hljs-keyword">float</span> width, <span class="hljs-keyword">float</span> height, <span class="hljs-keyword">float</span> length, Color color);             <span class="hljs-comment">// Draw cube</span>
    <span class="hljs-keyword">void</span> DrawCubeV(Vector3 position, Vector3 size, Color color);                                       <span class="hljs-comment">// Draw cube (Vector version)</span>
    <span class="hljs-keyword">void</span> DrawCubeWires(Vector3 position, <span class="hljs-keyword">float</span> width, <span class="hljs-keyword">float</span> height, <span class="hljs-keyword">float</span> length, Color color);        <span class="hljs-comment">// Draw cube wires</span>
    <span class="hljs-keyword">void</span> DrawCubeWiresV(Vector3 position, Vector3 size, Color color);                                  <span class="hljs-comment">// Draw cube wires (Vector version)</span>
    <span class="hljs-keyword">void</span> DrawSphere(Vector3 centerPos, <span class="hljs-keyword">float</span> radius, Color color);                                     <span class="hljs-comment">// Draw sphere</span>
    <span class="hljs-keyword">void</span> DrawSphereEx(Vector3 centerPos, <span class="hljs-keyword">float</span> radius, <span class="hljs-keyword">int</span> rings, <span class="hljs-keyword">int</span> slices, Color color);            <span class="hljs-comment">// Draw sphere with extended parameters</span>
    <span class="hljs-keyword">void</span> DrawSphereWires(Vector3 centerPos, <span class="hljs-keyword">float</span> radius, <span class="hljs-keyword">int</span> rings, <span class="hljs-keyword">int</span> slices, Color color);         <span class="hljs-comment">// Draw sphere wires</span>
    <span class="hljs-keyword">void</span> DrawCylinder(Vector3 position, <span class="hljs-keyword">float</span> radiusTop, <span class="hljs-keyword">float</span> radiusBottom, <span class="hljs-keyword">float</span> height, <span class="hljs-keyword">int</span> slices, Color color); <span class="hljs-comment">// Draw a cylinder/cone</span>
    <span class="hljs-keyword">void</span> DrawCylinderEx(Vector3 startPos, Vector3 endPos, <span class="hljs-keyword">float</span> startRadius, <span class="hljs-keyword">float</span> endRadius, <span class="hljs-keyword">int</span> sides, Color color); <span class="hljs-comment">// Draw a cylinder with base at startPos and top at endPos</span>
    <span class="hljs-keyword">void</span> DrawCylinderWires(Vector3 position, <span class="hljs-keyword">float</span> radiusTop, <span class="hljs-keyword">float</span> radiusBottom, <span class="hljs-keyword">float</span> height, <span class="hljs-keyword">int</span> slices, Color color); <span class="hljs-comment">// Draw a cylinder/cone wires</span>
    <span class="hljs-keyword">void</span> DrawCylinderWiresEx(Vector3 startPos, Vector3 endPos, <span class="hljs-keyword">float</span> startRadius, <span class="hljs-keyword">float</span> endRadius, <span class="hljs-keyword">int</span> sides, Color color); <span class="hljs-comment">// Draw a cylinder wires with base at startPos and top at endPos</span>
    <span class="hljs-keyword">void</span> DrawCapsule(Vector3 startPos, Vector3 endPos, <span class="hljs-keyword">float</span> radius, <span class="hljs-keyword">int</span> slices, <span class="hljs-keyword">int</span> rings, Color color); <span class="hljs-comment">// Draw a capsule with the center of its sphere caps at startPos and endPos</span>
    <span class="hljs-keyword">void</span> DrawCapsuleWires(Vector3 startPos, Vector3 endPos, <span class="hljs-keyword">float</span> radius, <span class="hljs-keyword">int</span> slices, <span class="hljs-keyword">int</span> rings, Color color); <span class="hljs-comment">// Draw capsule wireframe with the center of its sphere caps at startPos and endPos</span>
    <span class="hljs-keyword">void</span> DrawPlane(Vector3 centerPos, Vector2 size, Color color);                                      <span class="hljs-comment">// Draw a plane XZ</span>
    <span class="hljs-keyword">void</span> DrawRay(Ray ray, Color color);                                                                <span class="hljs-comment">// Draw a ray line</span>
    <span class="hljs-keyword">void</span> DrawGrid(<span class="hljs-keyword">int</span> slices, <span class="hljs-keyword">float</span> spacing);                                                          <span class="hljs-comment">// Draw a grid (centered at (0, 0, 0))</span><font></font>
<font></font>
    <span class="hljs-comment">//------------------------------------------------------------------------------------</span>
    <span class="hljs-comment">// Model 3d Loading and Drawing Functions (Module: models)</span>
    <span class="hljs-comment">//------------------------------------------------------------------------------------</span><font></font>
<font></font>
    <span class="hljs-comment">// Model management functions</span>
    Model LoadModel(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fileName);                                                <span class="hljs-comment">// Load model from files (meshes and materials)</span>
    Model LoadModelFromMesh(Mesh mesh);                                                   <span class="hljs-comment">// Load model from generated mesh (default material)</span>
    <span class="hljs-keyword">bool</span> IsModelReady(Model model);                                                       <span class="hljs-comment">// Check if a model is ready</span>
    <span class="hljs-keyword">void</span> UnloadModel(Model model);                                                        <span class="hljs-comment">// Unload model (including meshes) from memory (RAM and/or VRAM)</span>
    BoundingBox GetModelBoundingBox(Model model);                                         <span class="hljs-comment">// Compute model bounding box limits (considers all meshes)</span><font></font>
<font></font>
    <span class="hljs-comment">// Model drawing functions</span>
    <span class="hljs-keyword">void</span> DrawModel(Model model, Vector3 position, <span class="hljs-keyword">float</span> scale, Color tint);               <span class="hljs-comment">// Draw a model (with texture if set)</span>
    <span class="hljs-keyword">void</span> DrawModelEx(Model model, Vector3 position, Vector3 rotationAxis, <span class="hljs-keyword">float</span> rotationAngle, Vector3 scale, Color tint); <span class="hljs-comment">// Draw a model with extended parameters</span>
    <span class="hljs-keyword">void</span> DrawModelWires(Model model, Vector3 position, <span class="hljs-keyword">float</span> scale, Color tint);          <span class="hljs-comment">// Draw a model wires (with texture if set)</span>
    <span class="hljs-keyword">void</span> DrawModelWiresEx(Model model, Vector3 position, Vector3 rotationAxis, <span class="hljs-keyword">float</span> rotationAngle, Vector3 scale, Color tint); <span class="hljs-comment">// Draw a model wires (with texture if set) with extended parameters</span>
    <span class="hljs-keyword">void</span> DrawBoundingBox(BoundingBox box, Color color);                                   <span class="hljs-comment">// Draw bounding box (wires)</span>
    <span class="hljs-keyword">void</span> DrawBillboard(Camera camera, Texture2D texture, Vector3 position, <span class="hljs-keyword">float</span> size, Color tint);   <span class="hljs-comment">// Draw a billboard texture</span>
    <span class="hljs-keyword">void</span> DrawBillboardRec(Camera camera, Texture2D texture, Rectangle source, Vector3 position, Vector2 size, Color tint); <span class="hljs-comment">// Draw a billboard texture defined by source</span>
    <span class="hljs-keyword">void</span> DrawBillboardPro(Camera camera, Texture2D texture, Rectangle source, Vector3 position, Vector3 up, Vector2 size, Vector2 origin, <span class="hljs-keyword">float</span> rotation, Color tint); <span class="hljs-comment">// Draw a billboard texture defined by source and rotation</span><font></font>
<font></font>
    <span class="hljs-comment">// Mesh management functions</span>
    <span class="hljs-keyword">void</span> UploadMesh(Mesh *mesh, <span class="hljs-keyword">bool</span> dynamic);                                            <span class="hljs-comment">// Upload mesh vertex data in GPU and provide VAO/VBO ids</span>
    <span class="hljs-keyword">void</span> UpdateMeshBuffer(Mesh mesh, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *data, <span class="hljs-keyword">int</span> dataSize, <span class="hljs-keyword">int</span> offset); <span class="hljs-comment">// Update mesh vertex data in GPU for a specific buffer index</span>
    <span class="hljs-keyword">void</span> UnloadMesh(Mesh mesh);                                                           <span class="hljs-comment">// Unload mesh data from CPU and GPU</span>
    <span class="hljs-keyword">void</span> DrawMesh(Mesh mesh, Material material, Matrix transform);                        <span class="hljs-comment">// Draw a 3d mesh with material and transform</span>
    <span class="hljs-keyword">void</span> DrawMeshInstanced(Mesh mesh, Material material, <span class="hljs-keyword">const</span> Matrix *transforms, <span class="hljs-keyword">int</span> instances); <span class="hljs-comment">// Draw multiple mesh instances with material and different transforms</span>
    <span class="hljs-keyword">bool</span> ExportMesh(Mesh mesh, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fileName);                                     <span class="hljs-comment">// Export mesh data to file, returns true on success</span>
    BoundingBox GetMeshBoundingBox(Mesh mesh);                                            <span class="hljs-comment">// Compute mesh bounding box limits</span>
    <span class="hljs-keyword">void</span> GenMeshTangents(Mesh *mesh);                                                     <span class="hljs-comment">// Compute mesh tangents</span><font></font>
<font></font>
    <span class="hljs-comment">// Mesh generation functions</span>
    Mesh GenMeshPoly(<span class="hljs-keyword">int</span> sides, <span class="hljs-keyword">float</span> radius);                                            <span class="hljs-comment">// Generate polygonal mesh</span>
    Mesh GenMeshPlane(<span class="hljs-keyword">float</span> width, <span class="hljs-keyword">float</span> length, <span class="hljs-keyword">int</span> resX, <span class="hljs-keyword">int</span> resZ);                     <span class="hljs-comment">// Generate plane mesh (with subdivisions)</span>
    Mesh GenMeshCube(<span class="hljs-keyword">float</span> width, <span class="hljs-keyword">float</span> height, <span class="hljs-keyword">float</span> length);                            <span class="hljs-comment">// Generate cuboid mesh</span>
    Mesh GenMeshSphere(<span class="hljs-keyword">float</span> radius, <span class="hljs-keyword">int</span> rings, <span class="hljs-keyword">int</span> slices);                              <span class="hljs-comment">// Generate sphere mesh (standard sphere)</span>
    Mesh GenMeshHemiSphere(<span class="hljs-keyword">float</span> radius, <span class="hljs-keyword">int</span> rings, <span class="hljs-keyword">int</span> slices);                          <span class="hljs-comment">// Generate half-sphere mesh (no bottom cap)</span>
    Mesh GenMeshCylinder(<span class="hljs-keyword">float</span> radius, <span class="hljs-keyword">float</span> height, <span class="hljs-keyword">int</span> slices);                         <span class="hljs-comment">// Generate cylinder mesh</span>
    Mesh GenMeshCone(<span class="hljs-keyword">float</span> radius, <span class="hljs-keyword">float</span> height, <span class="hljs-keyword">int</span> slices);                             <span class="hljs-comment">// Generate cone/pyramid mesh</span>
    Mesh GenMeshTorus(<span class="hljs-keyword">float</span> radius, <span class="hljs-keyword">float</span> size, <span class="hljs-keyword">int</span> radSeg, <span class="hljs-keyword">int</span> sides);                   <span class="hljs-comment">// Generate torus mesh</span>
    Mesh GenMeshKnot(<span class="hljs-keyword">float</span> radius, <span class="hljs-keyword">float</span> size, <span class="hljs-keyword">int</span> radSeg, <span class="hljs-keyword">int</span> sides);                    <span class="hljs-comment">// Generate trefoil knot mesh</span>
    Mesh GenMeshHeightmap(Image heightmap, Vector3 size);                                 <span class="hljs-comment">// Generate heightmap mesh from image data</span>
    Mesh GenMeshCubicmap(Image cubicmap, Vector3 cubeSize);                               <span class="hljs-comment">// Generate cubes-based map mesh from image data</span><font></font>
<font></font>
    <span class="hljs-comment">// Material loading/unloading functions</span>
    Material *LoadMaterials(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fileName, <span class="hljs-keyword">int</span> *materialCount);                    <span class="hljs-comment">// Load materials from model file</span>
    Material LoadMaterialDefault(<span class="hljs-keyword">void</span>);                                                   <span class="hljs-comment">// Load default material (Supports: DIFFUSE, SPECULAR, NORMAL maps)</span>
    <span class="hljs-keyword">bool</span> IsMaterialReady(Material material);                                              <span class="hljs-comment">// Check if a material is ready</span>
    <span class="hljs-keyword">void</span> UnloadMaterial(Material material);                                               <span class="hljs-comment">// Unload material from GPU memory (VRAM)</span>
    <span class="hljs-keyword">void</span> SetMaterialTexture(Material *material, <span class="hljs-keyword">int</span> mapType, Texture2D texture);          <span class="hljs-comment">// Set texture for a material map type (MATERIAL_MAP_DIFFUSE, MATERIAL_MAP_SPECULAR...)</span>
    <span class="hljs-keyword">void</span> SetModelMeshMaterial(Model *model, <span class="hljs-keyword">int</span> meshId, <span class="hljs-keyword">int</span> materialId);                  <span class="hljs-comment">// Set material for a mesh</span><font></font>
<font></font>
    <span class="hljs-comment">// Model animations loading/unloading functions</span>
    ModelAnimation *LoadModelAnimations(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fileName, <span class="hljs-keyword">int</span> *animCount);            <span class="hljs-comment">// Load model animations from file</span>
    <span class="hljs-keyword">void</span> UpdateModelAnimation(Model model, ModelAnimation anim, <span class="hljs-keyword">int</span> frame);               <span class="hljs-comment">// Update model animation pose</span>
    <span class="hljs-keyword">void</span> UnloadModelAnimation(ModelAnimation anim);                                       <span class="hljs-comment">// Unload animation data</span>
    <span class="hljs-keyword">void</span> UnloadModelAnimations(ModelAnimation *animations, <span class="hljs-keyword">int</span> animCount);                <span class="hljs-comment">// Unload animation array data</span>
    <span class="hljs-keyword">bool</span> IsModelAnimationValid(Model model, ModelAnimation anim);                         <span class="hljs-comment">// Check model animation skeleton match</span><font></font>
<font></font>
    <span class="hljs-comment">// Collision detection functions</span>
    <span class="hljs-keyword">bool</span> CheckCollisionSpheres(Vector3 center1, <span class="hljs-keyword">float</span> radius1, Vector3 center2, <span class="hljs-keyword">float</span> radius2);   <span class="hljs-comment">// Check collision between two spheres</span>
    <span class="hljs-keyword">bool</span> CheckCollisionBoxes(BoundingBox box1, BoundingBox box2);                                 <span class="hljs-comment">// Check collision between two bounding boxes</span>
    <span class="hljs-keyword">bool</span> CheckCollisionBoxSphere(BoundingBox box, Vector3 center, <span class="hljs-keyword">float</span> radius);                  <span class="hljs-comment">// Check collision between box and sphere</span>
    RayCollision GetRayCollisionSphere(Ray ray, Vector3 center, <span class="hljs-keyword">float</span> radius);                    <span class="hljs-comment">// Get collision info between ray and sphere</span>
    RayCollision GetRayCollisionBox(Ray ray, BoundingBox box);                                    <span class="hljs-comment">// Get collision info between ray and box</span>
    RayCollision GetRayCollisionMesh(Ray ray, Mesh mesh, Matrix transform);                       <span class="hljs-comment">// Get collision info between ray and mesh</span>
    RayCollision GetRayCollisionTriangle(Ray ray, Vector3 p1, Vector3 p2, Vector3 p3);            <span class="hljs-comment">// Get collision info between ray and triangle</span>
    RayCollision GetRayCollisionQuad(Ray ray, Vector3 p1, Vector3 p2, Vector3 p3, Vector3 p4);    <span class="hljs-comment">// Get collision info between ray and quad</span><font></font>
<font></font>
</code></pre></div>
            <p id="paudio"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">модуль: raudio</font></font></p>
            <div id="audio"><pre><code class="cpp hljs ">    <span class="hljs-comment">// Audio device management functions</span>
    <span class="hljs-keyword">void</span> InitAudioDevice(<span class="hljs-keyword">void</span>);                                     <span class="hljs-comment">// Initialize audio device and context</span>
    <span class="hljs-keyword">void</span> CloseAudioDevice(<span class="hljs-keyword">void</span>);                                    <span class="hljs-comment">// Close the audio device and context</span>
    <span class="hljs-keyword">bool</span> IsAudioDeviceReady(<span class="hljs-keyword">void</span>);                                  <span class="hljs-comment">// Check if audio device has been initialized successfully</span>
    <span class="hljs-keyword">void</span> SetMasterVolume(<span class="hljs-keyword">float</span> volume);                             <span class="hljs-comment">// Set master volume (listener)</span>
    <span class="hljs-keyword">float</span> GetMasterVolume(<span class="hljs-keyword">void</span>);                                    <span class="hljs-comment">// Get master volume (listener)</span><font></font>
<font></font>
    <span class="hljs-comment">// Wave/Sound loading/unloading functions</span>
    Wave LoadWave(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fileName);                            <span class="hljs-comment">// Load wave data from file</span>
    Wave LoadWaveFromMemory(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fileType, <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *fileData, <span class="hljs-keyword">int</span> dataSize); <span class="hljs-comment">// Load wave from memory buffer, fileType refers to extension: i.e. '.wav'</span>
    <span class="hljs-keyword">bool</span> IsWaveReady(Wave wave);                                    <span class="hljs-comment">// Checks if wave data is ready</span>
    Sound LoadSound(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fileName);                          <span class="hljs-comment">// Load sound from file</span>
    Sound LoadSoundFromWave(Wave wave);                             <span class="hljs-comment">// Load sound from wave data</span>
    Sound LoadSoundAlias(Sound source);                             <span class="hljs-comment">// Create a new sound that shares the same sample data as the source sound, does not own the sound data</span>
    <span class="hljs-keyword">bool</span> IsSoundReady(Sound sound);                                 <span class="hljs-comment">// Checks if a sound is ready</span>
    <span class="hljs-keyword">void</span> UpdateSound(Sound sound, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *data, <span class="hljs-keyword">int</span> sampleCount); <span class="hljs-comment">// Update sound buffer with new data</span>
    <span class="hljs-keyword">void</span> UnloadWave(Wave wave);                                     <span class="hljs-comment">// Unload wave data</span>
    <span class="hljs-keyword">void</span> UnloadSound(Sound sound);                                  <span class="hljs-comment">// Unload sound</span>
    <span class="hljs-keyword">void</span> UnloadSoundAlias(Sound alias);                             <span class="hljs-comment">// Unload a sound alias (does not deallocate sample data)</span>
    <span class="hljs-keyword">bool</span> ExportWave(Wave wave, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fileName);               <span class="hljs-comment">// Export wave data to file, returns true on success</span>
    <span class="hljs-keyword">bool</span> ExportWaveAsCode(Wave wave, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fileName);         <span class="hljs-comment">// Export wave sample data to code (.h), returns true on success</span><font></font>
<font></font>
    <span class="hljs-comment">// Wave/Sound management functions</span>
    <span class="hljs-keyword">void</span> PlaySound(Sound sound);                                    <span class="hljs-comment">// Play a sound</span>
    <span class="hljs-keyword">void</span> StopSound(Sound sound);                                    <span class="hljs-comment">// Stop playing a sound</span>
    <span class="hljs-keyword">void</span> PauseSound(Sound sound);                                   <span class="hljs-comment">// Pause a sound</span>
    <span class="hljs-keyword">void</span> ResumeSound(Sound sound);                                  <span class="hljs-comment">// Resume a paused sound</span>
    <span class="hljs-keyword">bool</span> IsSoundPlaying(Sound sound);                               <span class="hljs-comment">// Check if a sound is currently playing</span>
    <span class="hljs-keyword">void</span> SetSoundVolume(Sound sound, <span class="hljs-keyword">float</span> volume);                 <span class="hljs-comment">// Set volume for a sound (1.0 is max level)</span>
    <span class="hljs-keyword">void</span> SetSoundPitch(Sound sound, <span class="hljs-keyword">float</span> pitch);                   <span class="hljs-comment">// Set pitch for a sound (1.0 is base level)</span>
    <span class="hljs-keyword">void</span> SetSoundPan(Sound sound, <span class="hljs-keyword">float</span> pan);                       <span class="hljs-comment">// Set pan for a sound (0.5 is center)</span>
    Wave WaveCopy(Wave wave);                                       <span class="hljs-comment">// Copy a wave to a new wave</span>
    <span class="hljs-keyword">void</span> WaveCrop(Wave *wave, <span class="hljs-keyword">int</span> initSample, <span class="hljs-keyword">int</span> finalSample);     <span class="hljs-comment">// Crop a wave to defined samples range</span>
    <span class="hljs-keyword">void</span> WaveFormat(Wave *wave, <span class="hljs-keyword">int</span> sampleRate, <span class="hljs-keyword">int</span> sampleSize, <span class="hljs-keyword">int</span> channels); <span class="hljs-comment">// Convert wave data to desired format</span>
    <span class="hljs-keyword">float</span> *LoadWaveSamples(Wave wave);                              <span class="hljs-comment">// Load samples data from wave as a 32bit float data array</span>
    <span class="hljs-keyword">void</span> UnloadWaveSamples(<span class="hljs-keyword">float</span> *samples);                         <span class="hljs-comment">// Unload samples data loaded with LoadWaveSamples()</span><font></font>
<font></font>
    <span class="hljs-comment">// Music management functions</span>
    Music LoadMusicStream(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fileName);                    <span class="hljs-comment">// Load music stream from file</span>
    Music LoadMusicStreamFromMemory(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fileType, <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *data, <span class="hljs-keyword">int</span> dataSize); <span class="hljs-comment">// Load music stream from data</span>
    <span class="hljs-keyword">bool</span> IsMusicReady(Music music);                                 <span class="hljs-comment">// Checks if a music stream is ready</span>
    <span class="hljs-keyword">void</span> UnloadMusicStream(Music music);                            <span class="hljs-comment">// Unload music stream</span>
    <span class="hljs-keyword">void</span> PlayMusicStream(Music music);                              <span class="hljs-comment">// Start music playing</span>
    <span class="hljs-keyword">bool</span> IsMusicStreamPlaying(Music music);                         <span class="hljs-comment">// Check if music is playing</span>
    <span class="hljs-keyword">void</span> UpdateMusicStream(Music music);                            <span class="hljs-comment">// Updates buffers for music streaming</span>
    <span class="hljs-keyword">void</span> StopMusicStream(Music music);                              <span class="hljs-comment">// Stop music playing</span>
    <span class="hljs-keyword">void</span> PauseMusicStream(Music music);                             <span class="hljs-comment">// Pause music playing</span>
    <span class="hljs-keyword">void</span> ResumeMusicStream(Music music);                            <span class="hljs-comment">// Resume playing paused music</span>
    <span class="hljs-keyword">void</span> SeekMusicStream(Music music, <span class="hljs-keyword">float</span> position);              <span class="hljs-comment">// Seek music to a position (in seconds)</span>
    <span class="hljs-keyword">void</span> SetMusicVolume(Music music, <span class="hljs-keyword">float</span> volume);                 <span class="hljs-comment">// Set volume for music (1.0 is max level)</span>
    <span class="hljs-keyword">void</span> SetMusicPitch(Music music, <span class="hljs-keyword">float</span> pitch);                   <span class="hljs-comment">// Set pitch for a music (1.0 is base level)</span>
    <span class="hljs-keyword">void</span> SetMusicPan(Music music, <span class="hljs-keyword">float</span> pan);                       <span class="hljs-comment">// Set pan for a music (0.5 is center)</span>
    <span class="hljs-keyword">float</span> GetMusicTimeLength(Music music);                          <span class="hljs-comment">// Get music time length (in seconds)</span>
    <span class="hljs-keyword">float</span> GetMusicTimePlayed(Music music);                          <span class="hljs-comment">// Get current music time played (in seconds)</span><font></font>
<font></font>
    <span class="hljs-comment">// AudioStream management functions</span>
    AudioStream LoadAudioStream(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> sampleRate, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> sampleSize, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> channels); <span class="hljs-comment">// Load audio stream (to stream raw audio pcm data)</span>
    <span class="hljs-keyword">bool</span> IsAudioStreamReady(AudioStream stream);                    <span class="hljs-comment">// Checks if an audio stream is ready</span>
    <span class="hljs-keyword">void</span> UnloadAudioStream(AudioStream stream);                     <span class="hljs-comment">// Unload audio stream and free memory</span>
    <span class="hljs-keyword">void</span> UpdateAudioStream(AudioStream stream, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *data, <span class="hljs-keyword">int</span> frameCount); <span class="hljs-comment">// Update audio stream buffers with data</span>
    <span class="hljs-keyword">bool</span> IsAudioStreamProcessed(AudioStream stream);                <span class="hljs-comment">// Check if any audio stream buffers requires refill</span>
    <span class="hljs-keyword">void</span> PlayAudioStream(AudioStream stream);                       <span class="hljs-comment">// Play audio stream</span>
    <span class="hljs-keyword">void</span> PauseAudioStream(AudioStream stream);                      <span class="hljs-comment">// Pause audio stream</span>
    <span class="hljs-keyword">void</span> ResumeAudioStream(AudioStream stream);                     <span class="hljs-comment">// Resume audio stream</span>
    <span class="hljs-keyword">bool</span> IsAudioStreamPlaying(AudioStream stream);                  <span class="hljs-comment">// Check if audio stream is playing</span>
    <span class="hljs-keyword">void</span> StopAudioStream(AudioStream stream);                       <span class="hljs-comment">// Stop audio stream</span>
    <span class="hljs-keyword">void</span> SetAudioStreamVolume(AudioStream stream, <span class="hljs-keyword">float</span> volume);    <span class="hljs-comment">// Set volume for audio stream (1.0 is max level)</span>
    <span class="hljs-keyword">void</span> SetAudioStreamPitch(AudioStream stream, <span class="hljs-keyword">float</span> pitch);      <span class="hljs-comment">// Set pitch for audio stream (1.0 is base level)</span>
    <span class="hljs-keyword">void</span> SetAudioStreamPan(AudioStream stream, <span class="hljs-keyword">float</span> pan);          <span class="hljs-comment">// Set pan for audio stream (0.5 is centered)</span>
    <span class="hljs-keyword">void</span> SetAudioStreamBufferSizeDefault(<span class="hljs-keyword">int</span> size);                 <span class="hljs-comment">// Default size for new audio streams</span>
    <span class="hljs-keyword">void</span> SetAudioStreamCallback(AudioStream stream, AudioCallback callback); <span class="hljs-comment">// Audio thread callback to request new data</span><font></font>
<font></font>
    <span class="hljs-keyword">void</span> AttachAudioStreamProcessor(AudioStream stream, AudioCallback processor); <span class="hljs-comment">// Attach audio stream processor to stream, receives the samples as &lt;float&gt;s</span>
    <span class="hljs-keyword">void</span> DetachAudioStreamProcessor(AudioStream stream, AudioCallback processor); <span class="hljs-comment">// Detach audio stream processor from stream</span><font></font>
<font></font>
    <span class="hljs-keyword">void</span> AttachAudioMixedProcessor(AudioCallback processor); <span class="hljs-comment">// Attach audio stream processor to the entire audio pipeline, receives the samples as &lt;float&gt;s</span>
    <span class="hljs-keyword">void</span> DetachAudioMixedProcessor(AudioCallback processor); <span class="hljs-comment">// Detach audio stream processor from the entire audio pipeline</span><font></font>
<font></font>
</code></pre></div>

            <div id="fullgroup">
                <div class="leftgroup">
                    <p id="pstructs"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">структуры</font></font></p>
                    <div id="structs"><pre><code class="cpp hljs ">    <span class="hljs-keyword">struct</span> Vector2;                <span class="hljs-comment">// Vector2, 2 components</span>
    <span class="hljs-keyword">struct</span> Vector3;                <span class="hljs-comment">// Vector3, 3 components</span>
    <span class="hljs-keyword">struct</span> Vector4;                <span class="hljs-comment">// Vector4, 4 components</span>
    <span class="hljs-keyword">struct</span> Matrix;                 <span class="hljs-comment">// Matrix, 4x4 components, column major, OpenGL style, right handed</span>
    <span class="hljs-keyword">struct</span> Color;                  <span class="hljs-comment">// Color, 4 components, R8G8B8A8 (32bit)</span>
    <span class="hljs-keyword">struct</span> Rectangle;              <span class="hljs-comment">// Rectangle, 4 components</span><font></font>
<font></font>
    <span class="hljs-keyword">struct</span> Image;                  <span class="hljs-comment">// Image, pixel data stored in CPU memory (RAM)</span>
    <span class="hljs-keyword">struct</span> Texture;                <span class="hljs-comment">// Texture, tex data stored in GPU memory (VRAM)</span>
    <span class="hljs-keyword">struct</span> RenderTexture;          <span class="hljs-comment">// RenderTexture, fbo for texture rendering</span>
    <span class="hljs-keyword">struct</span> NPatchInfo;             <span class="hljs-comment">// NPatchInfo, n-patch layout info</span>
    <span class="hljs-keyword">struct</span> GlyphInfo;              <span class="hljs-comment">// GlyphInfo, font characters glyphs info</span>
    <span class="hljs-keyword">struct</span> Font;                   <span class="hljs-comment">// Font, font texture and GlyphInfo array data</span><font></font>
<font></font>
    <span class="hljs-keyword">struct</span> Camera3D;               <span class="hljs-comment">// Camera, defines position/orientation in 3d space</span><font></font>
<font></font>
    <span class="hljs-keyword">struct</span> Camera2D;               <span class="hljs-comment">// Camera2D, defines position/orientation in 2d space</span>
    <span class="hljs-keyword">struct</span> Mesh;                   <span class="hljs-comment">// Mesh, vertex data and vao/vbo</span>
    <span class="hljs-keyword">struct</span> Shader;                 <span class="hljs-comment">// Shader</span>
    <span class="hljs-keyword">struct</span> MaterialMap;            <span class="hljs-comment">// MaterialMap</span>
    <span class="hljs-keyword">struct</span> Material;               <span class="hljs-comment">// Material, includes shader and maps</span>
    <span class="hljs-keyword">struct</span> Transform;              <span class="hljs-comment">// Transform, vectex transformation data</span>
    <span class="hljs-keyword">struct</span> BoneInfo;               <span class="hljs-comment">// Bone, skeletal animation bone</span>
    <span class="hljs-keyword">struct</span> Model;                  <span class="hljs-comment">// Model, meshes, materials and animation data</span>
    <span class="hljs-keyword">struct</span> ModelAnimation;         <span class="hljs-comment">// ModelAnimation</span>
    <span class="hljs-keyword">struct</span> Ray;                    <span class="hljs-comment">// Ray, ray for raycasting</span>
    <span class="hljs-keyword">struct</span> RayCollision;           <span class="hljs-comment">// RayCollision, ray hit information</span>
    <span class="hljs-keyword">struct</span> BoundingBox;            <span class="hljs-comment">// BoundingBox</span><font></font>
<font></font>
    <span class="hljs-keyword">struct</span> Wave;                   <span class="hljs-comment">// Wave, audio wave data</span>
    <span class="hljs-keyword">struct</span> AudioStream;            <span class="hljs-comment">// AudioStream, custom audio stream</span>
    <span class="hljs-keyword">struct</span> Sound;                  <span class="hljs-comment">// Sound</span>
    <span class="hljs-keyword">struct</span> Music;                  <span class="hljs-comment">// Music, audio stream, anything longer than ~10 seconds should be streamed</span><font></font>
<font></font>
    <span class="hljs-keyword">struct</span> VrDeviceInfo;           <span class="hljs-comment">// VrDeviceInfo, Head-Mounted-Display device parameters</span>
    <span class="hljs-keyword">struct</span> VrStereoConfig;         <span class="hljs-comment">// VrStereoConfig, VR stereo rendering configuration for simulator</span><font></font>
<font></font>
    <span class="hljs-keyword">struct</span> FilePathList;           <span class="hljs-comment">// File path list</span><font></font>
<font></font>
    <span class="hljs-keyword">struct</span> AutomationEvent;        <span class="hljs-comment">// Automation event</span>
    <span class="hljs-keyword">struct</span> AutomationEventList;    <span class="hljs-comment">// Automation event list</span>
</code></pre></div>
                </div>
                <div class="rightgroup">
                    <p id="pcolors"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">цвета</font></font></p>
                    <div id="colors"><pre><code class="cpp hljs ">    <span class="hljs-comment">// Custom raylib color palette for amazing visuals on WHITE background</span>
    <span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> LIGHTGRAY  (Color){ 200, 200, 200, 255 }   <span class="hljs-comment">// Light Gray</span></span>
    <span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> GRAY       (Color){ 130, 130, 130, 255 }   <span class="hljs-comment">// Gray</span></span>
    <span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> DARKGRAY   (Color){ 80, 80, 80, 255 }      <span class="hljs-comment">// Dark Gray</span></span>
    <span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> YELLOW     (Color){ 253, 249, 0, 255 }     <span class="hljs-comment">// Yellow</span></span>
    <span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> GOLD       (Color){ 255, 203, 0, 255 }     <span class="hljs-comment">// Gold</span></span>
    <span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> ORANGE     (Color){ 255, 161, 0, 255 }     <span class="hljs-comment">// Orange</span></span>
    <span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> PINK       (Color){ 255, 109, 194, 255 }   <span class="hljs-comment">// Pink</span></span>
    <span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> RED        (Color){ 230, 41, 55, 255 }     <span class="hljs-comment">// Red</span></span>
    <span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> MAROON     (Color){ 190, 33, 55, 255 }     <span class="hljs-comment">// Maroon</span></span>
    <span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> GREEN      (Color){ 0, 228, 48, 255 }      <span class="hljs-comment">// Green</span></span>
    <span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> LIME       (Color){ 0, 158, 47, 255 }      <span class="hljs-comment">// Lime</span></span>
    <span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> DARKGREEN  (Color){ 0, 117, 44, 255 }      <span class="hljs-comment">// Dark Green</span></span>
    <span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> SKYBLUE    (Color){ 102, 191, 255, 255 }   <span class="hljs-comment">// Sky Blue</span></span>
    <span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> BLUE       (Color){ 0, 121, 241, 255 }     <span class="hljs-comment">// Blue</span></span>
    <span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> DARKBLUE   (Color){ 0, 82, 172, 255 }      <span class="hljs-comment">// Dark Blue</span></span>
    <span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> PURPLE     (Color){ 200, 122, 255, 255 }   <span class="hljs-comment">// Purple</span></span>
    <span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> VIOLET     (Color){ 135, 60, 190, 255 }    <span class="hljs-comment">// Violet</span></span>
    <span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> DARKPURPLE (Color){ 112, 31, 126, 255 }    <span class="hljs-comment">// Dark Purple</span></span>
    <span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> BEIGE      (Color){ 211, 176, 131, 255 }   <span class="hljs-comment">// Beige</span></span>
    <span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> BROWN      (Color){ 127, 106, 79, 255 }    <span class="hljs-comment">// Brown</span></span>
    <span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> DARKBROWN  (Color){ 76, 63, 47, 255 }      <span class="hljs-comment">// Dark Brown</span></span><font></font>
<font></font>
    <span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> WHITE      (Color){ 255, 255, 255, 255 }   <span class="hljs-comment">// White</span></span>
    <span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> BLACK      (Color){ 0, 0, 0, 255 }         <span class="hljs-comment">// Black</span></span>
    <span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> BLANK      (Color){ 0, 0, 0, 0 }           <span class="hljs-comment">// Blank (Transparent)</span></span>
    <span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> MAGENTA    (Color){ 255, 0, 255, 255 }     <span class="hljs-comment">// Magenta</span></span>
    <span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> RAYWHITE   (Color){ 245, 245, 245, 255 }   <span class="hljs-comment">// My own White (raylib logo)</span></span>
</code></pre></div>
                </div>
            </div>

            <p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"></font></font></p>
            <ul>
                
            </ul>

            
        </div>
    

<div id="goog-gt-tt" class="skiptranslate" dir="ltr"><div style="padding: 8px;"><div><div class="logo"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciLz4=" width="20" height="20" alt="Google Translate"></div></div></div><div class="top" style="padding: 8px; float: left; width: 100%;"><h1 class="title gray">Original text</h1></div><div class="middle" style="padding: 8px;"><div class="original-text"></div></div><div class="bottom" style="padding: 8px;"><div class="activity-links"><span class="activity-link">Contribute a better translation</span><span class="activity-link"></span></div><div class="started-activity-container"><hr style="color: #CCC; background-color: #CCC; height: 1px; border: none;"><div class="activity-root"></div></div></div><div class="status-message" style="display: none;"></div></div><div id="shimeji-workArea" style="position: fixed; background: transparent; z-index: 2147483643; width: 100vw; height: 100vh; left: 0px; top: 0px; transform: translate(0px, 0px); pointer-events: none;"></div><div id="goog-gt-tt" class="skiptranslate" dir="ltr"><div style="padding: 8px;"><div><div class="logo"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciLz4=" width="20" height="20" alt="Google Translate"></div></div></div><div class="top" style="padding: 8px; float: left; width: 100%;"><h1 class="title gray">Original text</h1></div><div class="middle" style="padding: 8px;"><div class="original-text"></div></div><div class="bottom" style="padding: 8px;"><div class="activity-links"><span class="activity-link">Contribute a better translation</span><span class="activity-link"></span></div><div class="started-activity-container"><hr style="color: #CCC; background-color: #CCC; height: 1px; border: none;"><div class="activity-root"></div></div></div><div class="status-message" style="display: none;"></div></div><div class="goog-te-spinner-pos"><div class="goog-te-spinner-animation"><svg xmlns="http://www.w3.org/2000/svg" class="goog-te-spinner" width="96px" height="96px" viewBox="0 0 66 66"><circle class="goog-te-spinner-path" fill="none" stroke-width="6" stroke-linecap="round" cx="33" cy="33" r="30"></circle></svg></div></div><div class="goog-te-spinner-pos"><div class="goog-te-spinner-animation"><svg xmlns="http://www.w3.org/2000/svg" class="goog-te-spinner" width="96px" height="96px" viewBox="0 0 66 66"><circle class="goog-te-spinner-path" fill="none" stroke-width="6" stroke-linecap="round" cx="33" cy="33" r="30"></circle></svg></div></div></body></html>